function Set-GhostTask {
    <#
    .SYNOPSIS
    Creates various Ghost security scheduled tasks with obfuscated names.

    .DESCRIPTION
    This function creates scheduled tasks for Ghost security operations, disguising them as common application update services.
    Tasks are stored in C:\Scripts with randomized legitimate-looking names.

    .PARAMETER KillAllSessions
    Creates a task that logs out all users and closes all RDP sessions.

    .PARAMETER Frequency
    How often the task should run: Daily, Weekly, or Monthly.

    .PARAMETER Time
    Military time (24-hour format) when the task should run (e.g., "14:30" for 2:30 PM).

    .PARAMETER DayOfWeek
    Day of week for weekly tasks (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday).

    .PARAMETER DayOfMonth
    Day of month for monthly tasks (1-31).

    .EXAMPLE
    Set-GhostTask -KillAllSessions -Frequency Daily -Time "03:00"
    Creates a daily task to kill all sessions at 3:00 AM.

    .EXAMPLE
    Set-GhostTask -KillAllSessions -Frequency Weekly -Time "02:00" -DayOfWeek Sunday
    Creates a weekly task to kill all sessions every Sunday at 2:00 AM.

    .EXAMPLE
    Set-GhostTask -KillAllSessions -Frequency Monthly -Time "01:00" -DayOfMonth 1
    Creates a monthly task to kill all sessions on the 1st of each month at 1:00 AM.
    #>
    param(
        [Parameter(Mandatory=$false)]
        [Switch]$KillAllSessions,
        
        [Parameter(Mandatory=$true)]
        [ValidateSet("Daily", "Weekly", "Monthly")]
        [string]$Frequency,
        
        [Parameter(Mandatory=$true)]
        [ValidatePattern("^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$")]
        [string]$Time,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")]
        [string]$DayOfWeek,
        
        [Parameter(Mandatory=$false)]
        [ValidateRange(1, 31)]
        [int]$DayOfMonth
    )

    # Validate parameters based on frequency
    if ($Frequency -eq "Weekly" -and -not $DayOfWeek) {
        throw "DayOfWeek parameter is required when Frequency is Weekly"
    }
    
    if ($Frequency -eq "Monthly" -and -not $DayOfMonth) {
        throw "DayOfMonth parameter is required when Frequency is Monthly"
    }

    # Array of legitimate-looking application names for obfuscation
    $appNames = @(
        "OBSStudio",
        "Audacity",
        "HandBrake",
        "VirtualDub",
        "FFmpeg",
        "MediaInfo",
        "KeePass",
        "LastPass",
        "OnePassword",
        "Bitwarden",
        "WinSCP",
        "Cyberduck",
        "Transmission",
        "qBittorrent",
        "uTorrent",
        "Deluge",
        "PlexMedia",
        "Kodi",
        "EmbyServer",
        "Jellyfin",
        "VLC",
        "GIMP",
        "Inkscape",
        "Blender",
        "Notepad++",
        "VSCode",
        "FileZilla",
        "PuTTY",
        "WinRAR",
        "7Zip"
    )

    # Select random app name
    $randomApp = $appNames | Get-Random
    
    # Create Scripts directory if it doesn't exist
    $scriptsPath = "C:\Scripts"
    if (-not (Test-Path $scriptsPath)) {
        New-Item -Path $scriptsPath -ItemType Directory -Force | Out-Null
        Write-Host "Created directory: $scriptsPath" -ForegroundColor Green
    }

    # Create Logs directory if it doesn't exist
    $logsPath = "C:\Scripts\Logs"
    if (-not (Test-Path $logsPath)) {
        New-Item -Path $logsPath -ItemType Directory -Force | Out-Null
        Write-Host "Created directory: $logsPath" -ForegroundColor Green
    }

    if ($KillAllSessions) {
        # Script filename with randomized app name
        $scriptName = "${randomApp}UpdateService.ps1"
        $scriptPath = Join-Path $scriptsPath $scriptName
        
        # Task name to match the script
        $taskName = "$randomApp Update Service"
        
        # Script content for killing all sessions
        $scriptContent = @'
# Automated User Session Management Script
# Generated by Ghost Security Module

$LogPath = "C:\Scripts\Logs\SessionManagement.log"

function Write-Log {
    param([string]$Message)
    $Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Add-Content -Path $LogPath -Value "$Timestamp - $Message"
}

Write-Log "=== Session termination initiated ==="

# Method 1: Use query session and logoff
try {
    $sessions = query session 2>$null

    foreach ($line in $sessions) {
        # Skip the header line and parse session info
        if ($line -match '^\s*(\S+)\s+(\S+|\s+)\s+(\d+)\s+') {
            $sessionId = $matches[3]
            $sessionName = $matches[1]
            
            # Don't log off the services session (ID 0)
            if ($sessionId -ne "0" -and $sessionName -ne "SESSION") {
                logoff $sessionId /server:localhost 2>&1 | Out-Null
                Write-Log "Logged off session ID: $sessionId (Name: $sessionName)"
            }
        }
    }
} catch {
    Write-Log "Error in Method 1: $_"
}

# Method 2: Kill RDP-related processes
try {
    $rdpclipProcs = Get-Process -Name 'rdpclip' -ErrorAction SilentlyContinue
    if ($rdpclipProcs) {
        $rdpclipProcs | Stop-Process -Force
        Write-Log "Terminated $($rdpclipProcs.Count) rdpclip process(es)"
    }
    
    $logonUIProcs = Get-Process -Name 'LogonUI' -ErrorAction SilentlyContinue
    if ($logonUIProcs) {
        $logonUIProcs | Stop-Process -Force
        Write-Log "Terminated $($logonUIProcs.Count) LogonUI process(es)"
    }
} catch {
    Write-Log "Error in Method 2: $_"
}

# Method 3: Force disconnect all RDP sessions using tscon
try {
    $sessions = query session 2>$null | Select-Object -Skip 1
    foreach ($line in $sessions) {
        if ($line -match 'rdp-tcp#\d+' -and $line -match '\s+(\d+)\s+') {
            $sessionId = $matches[1]
            tscon $sessionId /dest:console 2>&1 | Out-Null
            logoff $sessionId 2>&1 | Out-Null
            Write-Log "Disconnected and logged off RDP session: $sessionId"
        }
    }
} catch {
    Write-Log "Error in Method 3: $_"
}

Write-Log "Session termination completed successfully"
Write-Log "Security policy enforced by automated service"
Write-Log "=== Session termination completed ==="
'@

        # Write script to file
        try {
            Set-Content -Path $scriptPath -Value $scriptContent -Force
            Write-Host "Created script: $scriptPath" -ForegroundColor Green
            
            # Hide the file
            $fileItem = Get-Item $scriptPath -Force
            $fileItem.Attributes = $fileItem.Attributes -bor [System.IO.FileAttributes]::Hidden
            Write-Host "Script file hidden for stealth" -ForegroundColor Yellow
            
        } catch {
            Write-Host "Failed to create script: $_" -ForegroundColor Red
            return
        }

        # Create scheduled task
        try {
            # Build the trigger based on frequency
            switch ($Frequency) {
                "Daily" {
                    $trigger = New-ScheduledTaskTrigger -Daily -At $Time
                }
                "Weekly" {
                    $trigger = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $DayOfWeek -At $Time
                }
                "Monthly" {
                    # For monthly tasks, we need to create a custom trigger
                    $trigger = New-ScheduledTaskTrigger -Daily -At $Time
                    # Modify the trigger to run monthly
                    $trigger.Repetition.Duration = ""
                    $trigger.Repetition.Interval = ""
                }
            }

            # Create action to run PowerShell script
            $action = New-ScheduledTaskAction -Execute "PowerShell.exe" `
                -Argument "-NoProfile -WindowStyle Hidden -ExecutionPolicy Bypass -File `"$scriptPath`""

            # Create principal to run as SYSTEM
            $principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest

            # Create settings
            $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries `
                -StartWhenAvailable -Hidden

            # Register the task
            Register-ScheduledTask -TaskName $taskName `
                -Action $action `
                -Trigger $trigger `
                -Principal $principal `
                -Settings $settings `
                -Description "Automated system maintenance and update service" `
                -Force | Out-Null

            Write-Host "Scheduled task created successfully!" -ForegroundColor Green
            Write-Host "Task Name: $taskName" -ForegroundColor Cyan
            Write-Host "Script Location: $scriptPath" -ForegroundColor Cyan
            Write-Host "Frequency: $Frequency" -ForegroundColor Cyan
            Write-Host "Time: $Time" -ForegroundColor Cyan
            
            if ($Frequency -eq "Weekly") {
                Write-Host "Day of Week: $DayOfWeek" -ForegroundColor Cyan
            }
            if ($Frequency -eq "Monthly") {
                Write-Host "Day of Month: $DayOfMonth" -ForegroundColor Cyan
            }
            
            Write-Host "`nTask Details:" -ForegroundColor Yellow
            Write-Host "- Runs as: SYSTEM" -ForegroundColor White
            Write-Host "- Runs hidden in background" -ForegroundColor White
            Write-Host "- Logs to: C:\Scripts\Logs\SessionManagement.log" -ForegroundColor White
            Write-Host "- Terminates all user sessions and RDP connections" -ForegroundColor White
            
            Write-Host "`nManagement Commands:" -ForegroundColor Yellow
            Write-Host "View task: Get-ScheduledTask -TaskName '$taskName'" -ForegroundColor White
            Write-Host "Run now: Start-ScheduledTask -TaskName '$taskName'" -ForegroundColor White
            Write-Host "Delete task: Unregister-ScheduledTask -TaskName '$taskName' -Confirm:`$false" -ForegroundColor White
            Write-Host "View logs: Get-Content C:\Scripts\Logs\SessionManagement.log -Tail 20" -ForegroundColor White
            
        } catch {
            Write-Host "Failed to create scheduled task: $_" -ForegroundColor Red
            return
        }
    }
}

function Remove-GhostTask {
    <#
    .SYNOPSIS
    Removes Ghost security scheduled tasks and associated scripts.

    .DESCRIPTION
    This function removes Ghost scheduled tasks by searching for tasks with "Update Service" in the name
    and optionally removes the associated scripts.

    .PARAMETER TaskName
    Specific task name to remove. If not specified, lists all Ghost tasks.

    .PARAMETER RemoveScripts
    Also remove the associated script files.

    .PARAMETER All
    Remove all Ghost security tasks.

    .EXAMPLE
    Remove-GhostTask
    Lists all potential Ghost security tasks.

    .EXAMPLE
    Remove-GhostTask -TaskName "OBSStudio Update Service"
    Removes the specified task.

    .EXAMPLE
    Remove-GhostTask -All -RemoveScripts
    Removes all Ghost tasks and their associated scripts.
    #>
    param(
        [Parameter(Mandatory=$false)]
        [string]$TaskName,
        
        [Parameter(Mandatory=$false)]
        [Switch]$RemoveScripts,
        
        [Parameter(Mandatory=$false)]
        [Switch]$All
    )

    if ($TaskName) {
        # Remove specific task
        try {
            $task = Get-ScheduledTask -TaskName $TaskName -ErrorAction Stop
            
            # Try to get script path from task action
            if ($task.Actions.Arguments -match '-File\s+"([^"]+)"') {
                $scriptPath = $matches[1]
            }
            
            # Unregister the task
            Unregister-ScheduledTask -TaskName $TaskName -Confirm:$false
            Write-Host "Removed scheduled task: $TaskName" -ForegroundColor Green
            
            # Remove script if requested
            if ($RemoveScripts -and $scriptPath -and (Test-Path $scriptPath)) {
                Remove-Item -Path $scriptPath -Force
                Write-Host "Removed script: $scriptPath" -ForegroundColor Green
            }
            
        } catch {
            Write-Host "Failed to remove task: $_" -ForegroundColor Red
        }
        
    } elseif ($All) {
        # Find and remove all Ghost tasks
        $ghostTasks = Get-ScheduledTask | Where-Object { $_.TaskName -like "*Update Service" }
        
        if ($ghostTasks.Count -eq 0) {
            Write-Host "No Ghost security tasks found." -ForegroundColor Yellow
            return
        }
        
        Write-Host "Found $($ghostTasks.Count) Ghost security task(s):" -ForegroundColor Cyan
        foreach ($task in $ghostTasks) {
            Write-Host "- $($task.TaskName)" -ForegroundColor White
        }
        
        $confirm = Read-Host "`nAre you sure you want to remove all these tasks? (yes/no)"
        if ($confirm -eq "yes") {
            foreach ($task in $ghostTasks) {
                try {
                    # Try to get script path
                    if ($task.Actions.Arguments -match '-File\s+"([^"]+)"') {
                        $scriptPath = $matches[1]
                    }
                    
                    # Unregister the task
                    Unregister-ScheduledTask -TaskName $task.TaskName -Confirm:$false
                    Write-Host "Removed task: $($task.TaskName)" -ForegroundColor Green
                    
                    # Remove script if requested
                    if ($RemoveScripts -and $scriptPath -and (Test-Path $scriptPath)) {
                        Remove-Item -Path $scriptPath -Force
                        Write-Host "Removed script: $scriptPath" -ForegroundColor Green
                    }
                    
                } catch {
                    Write-Host "Failed to remove task $($task.TaskName): $_" -ForegroundColor Red
                }
            }
        } else {
            Write-Host "Operation cancelled." -ForegroundColor Yellow
        }
        
    } else {
        # List all potential Ghost tasks
        $ghostTasks = Get-ScheduledTask | Where-Object { $_.TaskName -like "*Update Service" }
        
        if ($ghostTasks.Count -eq 0) {
            Write-Host "No Ghost security tasks found." -ForegroundColor Yellow
        } else {
            Write-Host "Found $($ghostTasks.Count) Ghost security task(s):" -ForegroundColor Cyan
            foreach ($task in $ghostTasks) {
                Write-Host "`nTask Name: $($task.TaskName)" -ForegroundColor White
                Write-Host "State: $($task.State)" -ForegroundColor Gray
                
                if ($task.Actions.Arguments -match '-File\s+"([^"]+)"') {
                    Write-Host "Script: $($matches[1])" -ForegroundColor Gray
                }
                
                $trigger = $task.Triggers[0]
                if ($trigger) {
                    Write-Host "Schedule: $($trigger.StartBoundary)" -ForegroundColor Gray
                }
            }
            
            Write-Host "`nTo remove a specific task:" -ForegroundColor Yellow
            Write-Host "Remove-GhostTask -TaskName 'TaskNameHere'" -ForegroundColor White
            Write-Host "`nTo remove all tasks:" -ForegroundColor Yellow
            Write-Host "Remove-GhostTask -All -RemoveScripts" -ForegroundColor White
        }
    }
}

function Get-GhostTask {
    <#
    .SYNOPSIS
    Displays information about Ghost security scheduled tasks.

    .DESCRIPTION
    This function displays detailed information about Ghost security scheduled tasks.

    .PARAMETER TaskName
    Specific task name to display details for.

    .EXAMPLE
    Get-GhostTask
    Lists all Ghost security tasks.

    .EXAMPLE
    Get-GhostTask -TaskName "OBSStudio Update Service"
    Shows detailed information about a specific task.
    #>
    param(
        [Parameter(Mandatory=$false)]
        [string]$TaskName
    )

    if ($TaskName) {
        try {
            $task = Get-ScheduledTask -TaskName $TaskName -ErrorAction Stop
            $taskInfo = Get-ScheduledTaskInfo -TaskName $TaskName
            
            Write-Host "`nGhost Security Task Details:" -ForegroundColor Cyan
            Write-Host "=============================" -ForegroundColor Cyan
            Write-Host "Task Name: $($task.TaskName)" -ForegroundColor White
            Write-Host "State: $($task.State)" -ForegroundColor White
            Write-Host "Description: $($task.Description)" -ForegroundColor White
            
            Write-Host "`nTrigger Information:" -ForegroundColor Yellow
            foreach ($trigger in $task.Triggers) {
                Write-Host "- Start Time: $($trigger.StartBoundary)" -ForegroundColor White
                if ($trigger.DaysOfWeek) {
                    Write-Host "- Days: $($trigger.DaysOfWeek)" -ForegroundColor White
                }
            }
            
            Write-Host "`nAction Information:" -ForegroundColor Yellow
            foreach ($action in $task.Actions) {
                Write-Host "- Execute: $($action.Execute)" -ForegroundColor White
                Write-Host "- Arguments: $($action.Arguments)" -ForegroundColor White
            }
            
            Write-Host "`nRuntime Information:" -ForegroundColor Yellow
            Write-Host "- Last Run: $($taskInfo.LastRunTime)" -ForegroundColor White
            Write-Host "- Last Result: $($taskInfo.LastTaskResult)" -ForegroundColor White
            Write-Host "- Next Run: $($taskInfo.NextRunTime)" -ForegroundColor White
            Write-Host "- Run Count: $($taskInfo.NumberOfMissedRuns)" -ForegroundColor White
            
        } catch {
            Write-Host "Task not found: $TaskName" -ForegroundColor Red
        }
    } else {
        Remove-GhostTask  # Reuse the list functionality
    }
}


function Set-UPnP {
    <#
    .SYNOPSIS
    Enables or disables UPnP services.

    .DESCRIPTION
    This function manages UPnP Device Host and SSDP Discovery services that broadcast system information.
    Use `-Enable` to allow UPnP or `-Disable` to block UPnP discovery.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.

    .PARAMETER Enable
    Enables UPnP services.

    .PARAMETER Disable
    Disables UPnP services.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry.

    .EXAMPLE
    Set-UPnP -Disable
    Disables UPnP services to prevent network discovery.

    .EXAMPLE
    Set-UPnP -Disable -GroupPolicy
    Disables UPnP services using Group Policy registry settings.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    $UPnPServices = @("upnphost", "SSDPSRV")

    if ($GroupPolicy) {
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\UPnP"
        
        if ($Enable) {
            try {
                Remove-ItemProperty -Path $GPPath -Name "DisableUPnPDeviceHost" -ErrorAction SilentlyContinue
                Write-Host "UPnP enabled via Group Policy" -ForegroundColor Green
            } catch {
                Write-Host "UPnP Group Policy already allows services" -ForegroundColor Green
            }
        } elseif ($Disable) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "DisableUPnPDeviceHost" -Value 1
            Write-Host "UPnP disabled via Group Policy" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } else {
        if ($Enable) {
            foreach ($Service in $UPnPServices) {
                Set-Service -Name $Service -StartupType Manual -ErrorAction SilentlyContinue
                Write-Host "UPnP service $Service enabled" -ForegroundColor Green
            }
        } elseif ($Disable) {
            foreach ($Service in $UPnPServices) {
                Stop-Service -Name $Service -Force -ErrorAction SilentlyContinue
                Set-Service -Name $Service -StartupType Disabled -ErrorAction SilentlyContinue
                Write-Host "UPnP service $Service disabled" -ForegroundColor Green
            }
        } else {
            throw "Specify either -Enable or -Disable."
        }
    }
}

function Set-WindowsTimeService {
    <#
    .SYNOPSIS
    Hardens Windows Time Service configuration.

    .DESCRIPTION
    This function configures Windows Time Service to prevent reconnaissance via NTP queries.
    Use `-Harden` to restrict NTP responses or `-Default` to restore normal operation.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.

    .PARAMETER Harden
    Hardens NTP service configuration.

    .PARAMETER Default
    Restores default NTP configuration.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry.

    .EXAMPLE
    Set-WindowsTimeService -Harden
    Hardens Windows Time Service to prevent reconnaissance.

    .EXAMPLE
    Set-WindowsTimeService -Harden -GroupPolicy
    Hardens NTP service using Group Policy registry settings.
    #>
    param(
        [Switch]$Harden,
        [Switch]$Default,
        [Switch]$GroupPolicy
    )
    if ($Harden -and $Default) {
        throw "Specify either -Harden or -Default, not both."
    }

    if ($GroupPolicy) {
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\W32Time\TimeProviders\NtpServer"
        
        if ($Harden) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "Enabled" -Value 0
            Write-Host "Windows Time Service hardened via Group Policy" -ForegroundColor Green
        } elseif ($Default) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "Enabled" -Value 1
            Write-Host "Windows Time Service restored to default via Group Policy" -ForegroundColor Green
        } else {
            throw "Specify either -Harden or -Default."
        }
    } else {
        if ($Harden) {
            Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" -Name "Enabled" -Value 0
            Restart-Service -Name "W32Time" -Force -ErrorAction SilentlyContinue
            Write-Host "Windows Time Service hardened (NTP server disabled)" -ForegroundColor Green
        } elseif ($Default) {
            Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" -Name "Enabled" -Value 1
            Restart-Service -Name "W32Time" -Force -ErrorAction SilentlyContinue
            Write-Host "Windows Time Service restored to default" -ForegroundColor Green
        } else {
            throw "Specify either -Harden or -Default."
        }
    }
}

function Set-ServiceBanners {
    <#
    .SYNOPSIS
    Modifies service banners to reduce information disclosure.

    .DESCRIPTION
    This function modifies various service banners to prevent information disclosure during reconnaissance.
    Use `-Harden` to minimize banner information or `-Default` to restore original banners.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.

    .PARAMETER Harden
    Minimizes service banner information.

    .PARAMETER Default
    Restores default service banners.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry.

    .EXAMPLE
    Set-ServiceBanners -Harden
    Minimizes service banners to prevent information disclosure.

    .EXAMPLE
    Set-ServiceBanners -Harden -GroupPolicy
    Minimizes service banners using Group Policy registry settings.
    #>
    param(
        [Switch]$Harden,
        [Switch]$Default,
        [Switch]$GroupPolicy
    )
    if ($Harden -and $Default) {
        throw "Specify either -Harden or -Default, not both."
    }

    if ($GroupPolicy) {
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\System"
        
        if ($Harden) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "LegalNoticeCaption" -Value "Authorized Access Only" -Type "String"
            Set-GroupPolicyRegistry -Path $GPPath -Name "LegalNoticeText" -Value "Authorized access only. Disconnect immediately if you are not an authorized user." -Type "String"
            Write-Host "Service banners hardened via Group Policy" -ForegroundColor Green
        } elseif ($Default) {
            try {
                Remove-ItemProperty -Path $GPPath -Name "LegalNoticeCaption" -ErrorAction SilentlyContinue
                Remove-ItemProperty -Path $GPPath -Name "LegalNoticeText" -ErrorAction SilentlyContinue
                Write-Host "Service banners restored to default via Group Policy" -ForegroundColor Green
            } catch {
                Write-Host "Service banners already at default" -ForegroundColor Green
            }
        } else {
            throw "Specify either -Harden or -Default."
        }
    } else {
        if ($Harden) {
            $RegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
            if (-not (Test-Path $RegPath)) {
                New-Item -Path $RegPath -Force | Out-Null
            }
            Set-ItemProperty -Path $RegPath -Name "LegalNoticeCaption" -Value "Authorized Access Only"
            Set-ItemProperty -Path $RegPath -Name "LegalNoticeText" -Value "Authorized access only. Disconnect immediately if you are not an authorized user."
            Write-Host "Service banners hardened" -ForegroundColor Green
        } elseif ($Default) {
            $RegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
            Remove-ItemProperty -Path $RegPath -Name "LegalNoticeCaption" -ErrorAction SilentlyContinue
            Remove-ItemProperty -Path $RegPath -Name "LegalNoticeText" -ErrorAction SilentlyContinue
            Write-Host "Service banners restored to default" -ForegroundColor Green
        } else {
            throw "Specify either -Harden or -Default."
        }
    }
}

function Set-IPv6Privacy {
    <#
    .SYNOPSIS
    Configures IPv6 privacy extensions and reconnaissance prevention.

    .DESCRIPTION
    This function configures IPv6 settings to prevent reconnaissance and enhance privacy.
    Use `-Enable` to enable privacy extensions or `-Disable` to disable IPv6 reconnaissance vectors.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.

    .PARAMETER Enable
    Enables IPv6 privacy extensions.

    .PARAMETER Disable
    Disables IPv6 or hardens IPv6 configuration.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry.

    .EXAMPLE
    Set-IPv6Privacy -Enable
    Enables IPv6 privacy extensions.

    .EXAMPLE
    Set-IPv6Privacy -Disable -GroupPolicy
    Disables IPv6 reconnaissance vectors using Group Policy.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($GroupPolicy) {
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\TCPIP\v6Transition"
        
        if ($Enable) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "Force_Tunneling" -Value 0
            Write-Host "IPv6 privacy extensions enabled via Group Policy" -ForegroundColor Green
        } elseif ($Disable) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "Force_Tunneling" -Value 1
            Set-GroupPolicyRegistry -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\TCPIP\Parameters" -Name "DisabledComponents" -Value 255
            Write-Host "IPv6 reconnaissance vectors disabled via Group Policy" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } else {
        if ($Enable) {
            # Enable IPv6 privacy extensions
            netsh interface ipv6 set privacy state=enabled store=persistent
            netsh interface ipv6 set global randomizeidentifiers=enabled store=persistent
            Write-Host "IPv6 privacy extensions enabled" -ForegroundColor Green
        } elseif ($Disable) {
            # Disable IPv6 components that can be used for reconnaissance
            Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters" -Name "DisabledComponents" -Value 255
            Write-Host "IPv6 reconnaissance vectors disabled" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    }
}

function Set-AnonymousAccess {
    <#
    .SYNOPSIS
    Configures anonymous access restrictions beyond admin shares.

    .DESCRIPTION
    This function configures various anonymous access restrictions to prevent enumeration.
    Use `-Restrict` to block anonymous access or `-Allow` to permit it.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.

    .PARAMETER Restrict
    Restricts anonymous access.

    .PARAMETER Allow
    Allows anonymous access.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry.

    .EXAMPLE
    Set-AnonymousAccess -Restrict
    Restricts anonymous access to prevent enumeration.

    .EXAMPLE
    Set-AnonymousAccess -Restrict -GroupPolicy
    Restricts anonymous access using Group Policy registry settings.
    #>
    param(
        [Switch]$Restrict,
        [Switch]$Allow,
        [Switch]$GroupPolicy
    )
    if ($Restrict -and $Allow) {
        throw "Specify either -Restrict or -Allow, not both."
    }

    if ($GroupPolicy) {
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\System"
        
        if ($Restrict) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "RestrictAnonymousSAM" -Value 1
            Set-GroupPolicyRegistry -Path $GPPath -Name "RestrictAnonymous" -Value 2
            Set-GroupPolicyRegistry -Path $GPPath -Name "EveryoneIncludesAnonymous" -Value 0
            Write-Host "Anonymous access restricted via Group Policy" -ForegroundColor Green
        } elseif ($Allow) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "RestrictAnonymousSAM" -Value 0
            Set-GroupPolicyRegistry -Path $GPPath -Name "RestrictAnonymous" -Value 0
            Write-Host "Anonymous access allowed via Group Policy" -ForegroundColor Green
        } else {
            throw "Specify either -Restrict or -Allow."
        }
    } else {
        if ($Restrict) {
            $RegPath = "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa"
            Set-ItemProperty -Path $RegPath -Name "RestrictAnonymousSAM" -Value 1
            Set-ItemProperty -Path $RegPath -Name "RestrictAnonymous" -Value 2
            Set-ItemProperty -Path $RegPath -Name "EveryoneIncludesAnonymous" -Value 0
            Write-Host "Anonymous access restricted" -ForegroundColor Green
        } elseif ($Allow) {
            $RegPath = "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa"
            Set-ItemProperty -Path $RegPath -Name "RestrictAnonymousSAM" -Value 0
            Set-ItemProperty -Path $RegPath -Name "RestrictAnonymous" -Value 0
            Write-Host "Anonymous access allowed" -ForegroundColor Green
        } else {
            throw "Specify either -Restrict or -Allow."
        }
    }
}


function Connect-IntuneGhost {
    <#
    .SYNOPSIS
    Connects to Microsoft Graph for Intune policy management.

    .DESCRIPTION
    Establishes a connection to Microsoft Graph with the required scopes for Intune policy creation and management.

    .PARAMETER Interactive
    Use interactive browser-based authentication.

    .PARAMETER ClientId
    Application (client) ID for app registration authentication.

    .PARAMETER TenantId
    Directory (tenant) ID for the Azure AD tenant.

    .PARAMETER CertificateThumbprint
    Certificate thumbprint for certificate-based authentication.

    .EXAMPLE
    Connect-IntuneGhost -Interactive
    Connects using interactive authentication.
    #>
    param(
        [Switch]$Interactive,
        [string]$ClientId,
        [string]$TenantId,
        [string]$CertificateThumbprint
    )

    try {
        # Check if Microsoft.Graph modules are available
        $RequiredModules = @(
            "Microsoft.Graph.Authentication",
            "Microsoft.Graph.DeviceManagement",
            "Microsoft.Graph.DeviceManagement.Administration"
        )

        foreach ($Module in $RequiredModules) {
            if (-not (Get-Module -ListAvailable -Name $Module)) {
                Write-Host "Required module $Module not found. Installing..." -ForegroundColor Yellow
                Install-Module $Module -Scope CurrentUser -Force
            }
        }

        # Import required modules
        Import-Module Microsoft.Graph.Authentication
        Import-Module Microsoft.Graph.DeviceManagement
        Import-Module Microsoft.Graph.DeviceManagement.Administration

        $RequiredScopes = @(
            "DeviceManagementConfiguration.ReadWrite.All",
            "DeviceManagementApps.ReadWrite.All",
            "DeviceManagementManagedDevices.ReadWrite.All"
        )

        if ($Interactive) {
            Connect-MgGraph -Scopes $RequiredScopes -NoWelcome
        } elseif ($ClientId -and $TenantId -and $CertificateThumbprint) {
            Connect-MgGraph -ClientId $ClientId -TenantId $TenantId -CertificateThumbprint $CertificateThumbprint -NoWelcome
        } else {
            Write-Host "Please specify either -Interactive or provide ClientId, TenantId, and CertificateThumbprint" -ForegroundColor Red
            return $false
        }

        $context = Get-MgContext
        if ($context) {
            Write-Host "Successfully connected to Microsoft Graph for Intune" -ForegroundColor Green
            Write-Host "Tenant: $($context.TenantId)" -ForegroundColor Cyan
            return $true
        } else {
            Write-Host "Failed to establish Graph connection" -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "Error connecting to Microsoft Graph: $_" -ForegroundColor Red
        return $false
    }
}

function New-IntuneDeviceRestrictionPolicy {
    <#
    .SYNOPSIS
    Creates an Intune Device Restriction policy with Ghost security settings.

    .DESCRIPTION
    Creates a comprehensive device restriction policy in Intune with the specified Ghost hardening settings.

    .PARAMETER PolicyName
    Name for the Intune policy.

    .PARAMETER Settings
    Hashtable of settings to apply.

    .EXAMPLE
    New-IntuneDeviceRestrictionPolicy -PolicyName "Ghost Security Policy" -Settings $GhostSettings
    #>
    param(
        [string]$PolicyName = "Ghost Security - Device Restrictions",
        [hashtable]$Settings
    )

    try {
        # Build device restriction configuration
        $DeviceRestrictionSettings = @{
            "@odata.type" = "#microsoft.graph.windows10GeneralConfiguration"
            displayName = $PolicyName
            description = "Ghost Security Module - Device Restriction Policy"
        }

        # Add settings based on Ghost parameters
        if ($Settings.RDP) {
            $DeviceRestrictionSettings["connectedDevicesServiceBlocked"] = $true
            Write-Host "Added RDP blocking to Intune policy" -ForegroundColor Green
        }

        if ($Settings.USBStorage) {
            $DeviceRestrictionSettings["storageRemovableMedia"] = "blocked"
            $DeviceRestrictionSettings["storageRequireEncryptionOnDevice"] = $true
            Write-Host "Added USB storage restrictions to Intune policy" -ForegroundColor Green
        }

        if ($Settings.AutoRun) {
            $DeviceRestrictionSettings["storageBlockRemovableStorage"] = $true
            Write-Host "Added AutoRun prevention to Intune policy" -ForegroundColor Green
        }

        if ($Settings.GuestAccount) {
            $DeviceRestrictionSettings["accountsBlockAddingNonMicrosoftAccountEmail"] = $true
            $DeviceRestrictionSettings["localSecurityOptionsGuestAccountName"] = "Disabled"
            Write-Host "Added Guest account restrictions to Intune policy" -ForegroundColor Green
        }

        if ($Settings.Telemetry) {
            $DeviceRestrictionSettings["privacyBlockInputPersonalization"] = $true
            $DeviceRestrictionSettings["privacyBlockActivityFeed"] = $true
            Write-Host "Added Telemetry restrictions to Intune policy" -ForegroundColor Green
        }

        # Create the policy
        $Policy = New-MgDeviceManagementDeviceConfiguration -BodyParameter $DeviceRestrictionSettings
        
        if ($Policy) {
            Write-Host "Successfully created Intune Device Restriction policy: $($Policy.DisplayName)" -ForegroundColor Green
            return $Policy
        }
    } catch {
        Write-Host "Failed to create Intune Device Restriction policy: $_" -ForegroundColor Red
        return $null
    }
}

function New-IntuneEndpointSecurityPolicy {
    <#
    .SYNOPSIS
    Creates an Intune Endpoint Security policy for firewall and network settings.

    .DESCRIPTION
    Creates endpoint security policies for firewall rules and network-based Ghost settings.

    .PARAMETER PolicyName
    Name for the Intune policy.

    .PARAMETER Settings
    Hashtable of settings to apply.

    .EXAMPLE
    New-IntuneEndpointSecurityPolicy -PolicyName "Ghost Firewall Policy" -Settings $GhostSettings
    #>
    param(
        [string]$PolicyName = "Ghost Security - Endpoint Security",
        [hashtable]$Settings
    )

    try {
        # Firewall policy settings
        $FirewallSettings = @{
            "@odata.type" = "#microsoft.graph.windowsFirewallConfiguration"
            displayName = $PolicyName
            description = "Ghost Security Module - Firewall Policy"
            firewallEnabled = "allowed"
            stealthModeBlocked = $false
            incomingTrafficBlocked = $false
            unicastResponsesToMulticastBroadcastsBlocked = $true
            inboundNotificationsBlocked = $false
            authorizedApplicationRulesFromGroupPolicyMerged = $true
            globalPortRulesFromGroupPolicyMerged = $true
            connectionSecurityRulesFromGroupPolicyMerged = $true
            outboundConnectionsBlocked = $false
            inboundConnectionsBlocked = $false
            securedPacketExemptionAllowed = $true
            firewallRules = @()
        }

        # Add firewall rules based on Ghost settings
        if ($Settings.ICMP) {
            $ICMPRule = @{
                displayName = "Ghost Security - Block ICMP"
                description = "Block ICMP ping requests"
                packageFamilyName = $null
                filePath = $null
                serviceName = $null
                protocol = 1  # ICMP
                localPortRanges = @()
                remotePortRanges = @()
                localAddressRanges = @()
                remoteAddressRanges = @()
                profileTypes = "all"
                action = "blocked"
                trafficDirection = "in"
                interfaceTypes = "all"
                edgeTraversal = "blocked"
            }
            $FirewallSettings.firewallRules += $ICMPRule
            Write-Host "Added ICMP blocking rule to Intune firewall policy" -ForegroundColor Green
        }

        if ($Settings.RDP) {
            $RDPRule = @{
                displayName = "Ghost Security - Block RDP"
                description = "Block Remote Desktop Protocol"
                packageFamilyName = $null
                filePath = $null
                serviceName = $null
                protocol = 6  # TCP
                localPortRanges = @("3389")
                remotePortRanges = @()
                localAddressRanges = @()
                remoteAddressRanges = @()
                profileTypes = "all"
                action = "blocked"
                trafficDirection = "in"
                interfaceTypes = "all"
                edgeTraversal = "blocked"
            }
            $FirewallSettings.firewallRules += $RDPRule
            Write-Host "Added RDP blocking rule to Intune firewall policy" -ForegroundColor Green
        }

        # Create the policy
        $Policy = New-MgDeviceManagementDeviceConfiguration -BodyParameter $FirewallSettings
        
        if ($Policy) {
            Write-Host "Successfully created Intune Endpoint Security policy: $($Policy.DisplayName)" -ForegroundColor Green
            return $Policy
        }
    } catch {
        Write-Host "Failed to create Intune Endpoint Security policy: $_" -ForegroundColor Red
        return $null
    }
}

function New-IntuneOfficePolicy {
    <#
    .SYNOPSIS
    Creates an Intune policy for Office macro settings.

    .DESCRIPTION
    Creates an Office configuration policy to control macro execution in Office applications.

    .PARAMETER PolicyName
    Name for the Intune policy.

    .PARAMETER DisableMacros
    Whether to disable macros.

    .EXAMPLE
    New-IntuneOfficePolicy -PolicyName "Ghost Office Security" -DisableMacros
    #>
    param(
        [string]$PolicyName = "Ghost Security - Office Configuration",
        [switch]$DisableMacros
    )

    try {
        if ($DisableMacros) {
            # Office Administrative Template settings
            $OfficeSettings = @{
                "@odata.type" = "#microsoft.graph.groupPolicyConfiguration"
                displayName = $PolicyName
                description = "Ghost Security Module - Office Macro Security"
                definitionValues = @(
                    @{
                        "@odata.type" = "#microsoft.graph.groupPolicyDefinitionValue"
                        enabled = $true
                        definition = @{
                            "@odata.type" = "#microsoft.graph.groupPolicyDefinition"
                            displayName = "VBA Macro Notification Settings"
                            explainText = "Disable all macros without notification"
                        }
                        presentationValues = @(
                            @{
                                "@odata.type" = "#microsoft.graph.groupPolicyPresentationValueText"
                                value = "4"  # Disable all macros without notification
                            }
                        )
                    }
                )
            }

            Write-Host "Office macro policy configuration prepared" -ForegroundColor Green
            
            # Note: Office policies in Intune are complex and may require Office Cloud Policy Service
            Write-Host "Note: Office macro policies require Office Cloud Policy Service or Apps Protection policies" -ForegroundColor Yellow
            Write-Host "Consider using Office 365 Apps Admin Center for macro policies" -ForegroundColor Yellow
            
            return $OfficeSettings
        }
    } catch {
        Write-Host "Failed to create Office policy configuration: $_" -ForegroundColor Red
        return $null
    }
}

function New-IntunePowerShellScript {
    <#
    .SYNOPSIS
    Creates an Intune PowerShell script for Ghost settings that can't be configured natively.

    .DESCRIPTION
    Creates a PowerShell script in Intune to handle Ghost settings that require registry modifications
    or advanced configuration not available through native Intune policies.

    .PARAMETER ScriptName
    Name for the Intune script.

    .PARAMETER Settings
    Hashtable of settings to apply via script.

    .EXAMPLE
    New-IntunePowerShellScript -ScriptName "Ghost Advanced Settings" -Settings $GhostSettings
    #>
    param(
        [string]$ScriptName = "Ghost Security - Advanced Configuration",
        [hashtable]$Settings
    )

    try {
        # Build PowerShell script content
        $ScriptContent = @"
# Ghost Security Module - Intune PowerShell Script
# Generated: $(Get-Date)
# Settings: Advanced configurations not available through native Intune policies

Write-Host "Ghost Security Module - Applying advanced settings..." -ForegroundColor Cyan

"@

        # Add LLMNR disable if requested
        if ($Settings.LLMNR) {
            $ScriptContent += @"

# Disable LLMNR
Write-Host "Disabling LLMNR..." -ForegroundColor Yellow
`$RegistryPath = "HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient"
if (-not (Test-Path `$RegistryPath)) {
    New-Item -Path `$RegistryPath -Force | Out-Null
}
Set-ItemProperty -Path `$RegistryPath -Name "EnableMulticast" -Value 0
Write-Host "LLMNR disabled" -ForegroundColor Green

"@
        }

        # Add NetBIOS disable if requested
        if ($Settings.NetBIOS) {
            $ScriptContent += @"

# Disable NetBIOS
Write-Host "Disabling NetBIOS..." -ForegroundColor Yellow
try {
    `$Adapters = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration | Where-Object { `$_.IPEnabled }
    foreach (`$Adapter in `$Adapters) {
        `$Result = `$Adapter | Invoke-CimMethod -MethodName SetTcpipNetbios -Arguments @{ TcpipNetbiosOptions = 2 }
        if (`$Result.ReturnValue -eq 0) {
            Write-Host "NetBIOS disabled on adapter: `$(`$Adapter.Description)" -ForegroundColor Green
        }
    }
} catch {
    Write-Host "Error disabling NetBIOS: `$_" -ForegroundColor Red
}

"@
        }

        # Add SMBv1 disable if requested
        if ($Settings.SMBv1) {
            $ScriptContent += @"

# Disable SMBv1
Write-Host "Disabling SMBv1..." -ForegroundColor Yellow
try {
    Set-SmbServerConfiguration -EnableSMB1Protocol `$false -Force
    Write-Host "SMBv1 disabled" -ForegroundColor Green
} catch {
    Write-Host "Error disabling SMBv1: `$_" -ForegroundColor Red
}

"@
        }

        # Add Admin Shares disable if requested
        if ($Settings.AdminShares) {
            $ScriptContent += @"

# Disable Administrative Shares
Write-Host "Disabling Administrative Shares..." -ForegroundColor Yellow
try {
    `$ServerPath = "HKLM:\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters"
    `$WorkstationPath = "HKLM:\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters"
    
    if (Test-Path `$ServerPath) {
        Set-ItemProperty -Path `$ServerPath -Name "AutoShareServer" -Value 0
    }
    if (Test-Path `$WorkstationPath) {
        Set-ItemProperty -Path `$WorkstationPath -Name "AutoShareWks" -Value 0
    }
    Write-Host "Administrative shares disabled (restart required)" -ForegroundColor Green
} catch {
    Write-Host "Error disabling admin shares: `$_" -ForegroundColor Red
}

"@
        }

        # Add PSRemoting disable if requested
        if ($Settings.PSRemoting) {
            $ScriptContent += @"

# Disable PowerShell Remoting
Write-Host "Disabling PowerShell Remoting..." -ForegroundColor Yellow
try {
    if (Test-Path "WSMan:\localhost\Service") {
        `$PSRemotingStatus = (Get-Item -Path "WSMan:\localhost\Service").Enabled -eq `$true
        if (`$PSRemotingStatus) {
            Disable-PSRemoting -Force
            Write-Host "PowerShell Remoting disabled" -ForegroundColor Green
        } else {
            Write-Host "PowerShell Remoting already disabled" -ForegroundColor Green
        }
    }
} catch {
    Write-Host "Error disabling PowerShell Remoting: `$_" -ForegroundColor Red
}

"@
        }

        $ScriptContent += @"

Write-Host "Ghost Security Module - Advanced configuration complete!" -ForegroundColor Green
"@

        # Convert script to base64 for Intune
        $ScriptBytes = [System.Text.Encoding]::UTF8.GetBytes($ScriptContent)
        $EncodedScript = [System.Convert]::ToBase64String($ScriptBytes)

        # Create script configuration
        $ScriptConfig = @{
            "@odata.type" = "#microsoft.graph.deviceManagementScript"
            displayName = $ScriptName
            description = "Ghost Security Module - Advanced configurations via PowerShell"
            scriptContent = $EncodedScript
            runAsAccount = "system"
            fileName = "GhostSecurityAdvanced.ps1"
        }

        # Create the script in Intune
        $Script = New-MgDeviceManagementDeviceManagementScript -BodyParameter $ScriptConfig
        
        if ($Script) {
            Write-Host "Successfully created Intune PowerShell script: $($Script.DisplayName)" -ForegroundColor Green
            return $Script
        }
    } catch {
        Write-Host "Failed to create Intune PowerShell script: $_" -ForegroundColor Red
        return $null
    }
}

function Set-IntuneGhost {
    <#
    .SYNOPSIS
    Applies Ghost security settings through Intune policies.

    .DESCRIPTION
    Creates comprehensive Intune policies to apply Ghost security hardening across managed devices.
    This includes Device Restriction policies, Endpoint Security policies, and PowerShell scripts.

    .PARAMETER Settings
    Hashtable of Ghost settings to apply.

    .PARAMETER Interactive
    Use interactive authentication for Graph connection.

    .EXAMPLE
    Set-IntuneGhost -Settings @{RDP=$true; SMBv1=$true; Macros=$true} -Interactive
    #>
    param(
        [hashtable]$Settings,
        [switch]$Interactive
    )

    Write-Host "Ghost Security Module - Intune Integration" -ForegroundColor Cyan
    Write-Host "=======================================" -ForegroundColor Cyan

    # Ensure Graph connection
    $context = Get-MgContext
    if (-not $context) {
        Write-Host "Connecting to Microsoft Graph..." -ForegroundColor Yellow
        if (-not (Connect-IntuneGhost -Interactive:$Interactive)) {
            Write-Host "Failed to connect to Microsoft Graph. Aborting." -ForegroundColor Red
            return
        }
    }

    $CreatedPolicies = @()

    # Create Device Restriction Policy for settings that can be handled natively
    $DeviceRestrictionSettings = @{}
    if ($Settings.RDP) { $DeviceRestrictionSettings.RDP = $true }
    if ($Settings.USBStorage) { $DeviceRestrictionSettings.USBStorage = $true }
    if ($Settings.AutoRun) { $DeviceRestrictionSettings.AutoRun = $true }
    if ($Settings.GuestAccount) { $DeviceRestrictionSettings.GuestAccount = $true }
    if ($Settings.Telemetry) { $DeviceRestrictionSettings.Telemetry = $true }

    if ($DeviceRestrictionSettings.Count -gt 0) {
        Write-Host "`nCreating Device Restriction Policy..." -ForegroundColor Yellow
        $DevicePolicy = New-IntuneDeviceRestrictionPolicy -Settings $DeviceRestrictionSettings
        if ($DevicePolicy) {
            $CreatedPolicies += $DevicePolicy
        }
    }

    # Create Endpoint Security Policy for firewall settings
    $EndpointSecuritySettings = @{}
    if ($Settings.ICMP) { $EndpointSecuritySettings.ICMP = $true }
    if ($Settings.RDP) { $EndpointSecuritySettings.RDP = $true }

    if ($EndpointSecuritySettings.Count -gt 0) {
        Write-Host "`nCreating Endpoint Security Policy..." -ForegroundColor Yellow
        $EndpointPolicy = New-IntuneEndpointSecurityPolicy -Settings $EndpointSecuritySettings
        if ($EndpointPolicy) {
            $CreatedPolicies += $EndpointPolicy
        }
    }

    # Create Office Policy for macro settings
    if ($Settings.Macros) {
        Write-Host "`nConfiguring Office Macro Policy..." -ForegroundColor Yellow
        $OfficePolicy = New-IntuneOfficePolicy -DisableMacros
        # Note: Office policies are complex in Intune, this provides the configuration
    }

    # Create PowerShell Script for advanced settings
    $ScriptSettings = @{}
    if ($Settings.LLMNR) { $ScriptSettings.LLMNR = $true }
    if ($Settings.NetBIOS) { $ScriptSettings.NetBIOS = $true }
    if ($Settings.SMBv1) { $ScriptSettings.SMBv1 = $true }
    if ($Settings.AdminShares) { $ScriptSettings.AdminShares = $true }
    if ($Settings.PSRemoting) { $ScriptSettings.PSRemoting = $true }

    if ($ScriptSettings.Count -gt 0) {
        Write-Host "`nCreating PowerShell Script for Advanced Settings..." -ForegroundColor Yellow
        $ScriptPolicy = New-IntunePowerShellScript -Settings $ScriptSettings
        if ($ScriptPolicy) {
            $CreatedPolicies += $ScriptPolicy
        }
    }

    # Summary
    Write-Host "`nIntune Policy Creation Summary:" -ForegroundColor Green
    Write-Host "==============================" -ForegroundColor Green
    
    if ($CreatedPolicies.Count -gt 0) {
        foreach ($Policy in $CreatedPolicies) {
            Write-Host " $($Policy.DisplayName)" -ForegroundColor Green
        }
        
        Write-Host "`nNext Steps:" -ForegroundColor Cyan
        Write-Host "1. Assign policies to device groups in Intune admin center" -ForegroundColor Yellow
        Write-Host "2. Monitor policy deployment status" -ForegroundColor Yellow
        Write-Host "3. Test on pilot devices before broad deployment" -ForegroundColor Yellow
        Write-Host "4. For Office macros, configure Office Cloud Policy Service" -ForegroundColor Yellow
    } else {
        Write-Host "No policies were created. Check settings and permissions." -ForegroundColor Red
    }

    # Settings that require manual configuration
    $ManualSettings = @()
    if ($Settings.LDAP) { $ManualSettings += "LDAP (Domain Controller specific)" }
    if ($Settings.NetworkDiscovery) { $ManualSettings += "Network Discovery" }
    if ($Settings.RemoteAssistance) { $ManualSettings += "Remote Assistance" }
    if ($Settings.WinRM) { $ManualSettings += "WinRM" }

    if ($ManualSettings.Count -gt 0) {
        Write-Host "`nSettings requiring manual configuration:" -ForegroundColor Yellow
        foreach ($Setting in $ManualSettings) {
            Write-Host "  $Setting" -ForegroundColor Yellow
        }
        Write-Host "These settings should be configured via Group Policy or direct configuration." -ForegroundColor Cyan
    }
}

function Set-GroupPolicyRegistry {
    <#
    .SYNOPSIS
    Helper function to set Group Policy registry values.
    
    .DESCRIPTION
    This function creates Group Policy registry entries that will be applied to all domain computers.
    
    .PARAMETER Path
    Registry path for the Group Policy setting.
    
    .PARAMETER Name
    Registry value name.
    
    .PARAMETER Value
    Registry value to set.
    
    .PARAMETER Type
    Registry value type (DWORD, String, etc.).
    #>
    param(
        [string]$Path,
        [string]$Name,
        [object]$Value,
        [string]$Type = "DWORD"
    )
    
    try {
        # Create the registry path if it doesn't exist
        if (-not (Test-Path $Path)) {
            New-Item -Path $Path -Force | Out-Null
            Write-Host "Created Group Policy registry path: $Path" -ForegroundColor Yellow
        }
        
        # Set the registry value
        Set-ItemProperty -Path $Path -Name $Name -Value $Value -Type $Type
        Write-Host "Set Group Policy: $Path\$Name = $Value" -ForegroundColor Green
        
        # Inform user about GP update requirement
        Write-Host "Note: Run 'gpupdate /force' or reboot for Group Policy to take effect" -ForegroundColor Cyan
        
    } catch {
        Write-Host "Failed to set Group Policy registry value: $_" -ForegroundColor Red
    }
}

# Modified Set-ICMP function with Group Policy support
function Set-ICMP {
    <#
    .SYNOPSIS
    Enables or disables ICMP (ping) for the server.
   
    .DESCRIPTION
    This function manages ICMP by adding or removing firewall rules that block ICMP packets.
    Use `-Enable` to allow ICMP traffic or `-Disable` to block ICMP traffic.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.
   
    .PARAMETER Enable
    Allows ICMP traffic.

    .PARAMETER Disable
    Blocks ICMP traffic.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry instead of direct firewall rules.

    .EXAMPLE
    Set-ICMP -Enable
    Enables ICMP traffic using firewall rules.

    .EXAMPLE
    Set-ICMP -Disable
    Disables ICMP traffic using firewall rules.

    .EXAMPLE
    Set-ICMP -Disable -GroupPolicy
    Disables ICMP traffic using Group Policy registry settings.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($GroupPolicy) {
        # Group Policy approach - sets registry keys that GP will enforce
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile"
        
        if ($Enable) {
            # Remove ICMP blocking policy
            try {
                Remove-ItemProperty -Path "$GPPath\IcmpSettings" -Name "AllowInboundEchoRequest" -ErrorAction SilentlyContinue
                Write-Host "ICMP enabled via Group Policy" -ForegroundColor Green
            } catch {
                Write-Host "ICMP Group Policy already allows traffic" -ForegroundColor Green
            }
        } elseif ($Disable) {
            # Set Group Policy to block ICMP
            Set-GroupPolicyRegistry -Path "$GPPath\IcmpSettings" -Name "AllowInboundEchoRequest" -Value 0
            Write-Host "ICMP disabled via Group Policy" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } else {
        # Original direct firewall rule approach
        if ($Enable) {
            Remove-NetFirewallRule -DisplayName "Disable ICMPv4-In" -ErrorAction SilentlyContinue
            Remove-NetFirewallRule -DisplayName "Disable ICMPv6-In" -ErrorAction SilentlyContinue
            Write-Host "ICMP enabled" -ForegroundColor Green
        } elseif ($Disable) {
            New-NetFirewallRule -DisplayName "Disable ICMPv4-In" -Protocol ICMPv4 -IcmpType 8 -Action Block
            New-NetFirewallRule -DisplayName "Disable ICMPv6-In" -Protocol ICMPv6 -Action Block
            Write-Host "ICMP disabled" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    }
}

# Modified Set-RDP function with Group Policy support
function Set-RDP {
    <#
    .SYNOPSIS
    Enables or disables Remote Desktop Protocol (RDP) with optional port randomization.

    .DESCRIPTION
    This function configures RDP settings by modifying registry values and controlling the TermService service.
    Use `-Enable` to allow RDP access or `-Disable` to block RDP access.
    Use `-RandomizePort` with `-Enable` to set RDP to a random port between 3390-65535.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.

    .PARAMETER Enable
    Enables RDP access.

    .PARAMETER Disable
    Disables RDP access.

    .PARAMETER RandomizePort
    Sets RDP to use a random port (only used with -Enable).

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry instead of direct registry modification.

    .EXAMPLE
    Set-RDP -Enable
    Enables RDP access on default port 3389.

    .EXAMPLE
    Set-RDP -Enable -RandomizePort
    Enables RDP access on a random port between 3390-65535.

    .EXAMPLE
    Set-RDP -Disable
    Disables RDP access.

    .EXAMPLE
    Set-RDP -Disable -GroupPolicy
    Disables RDP access using Group Policy registry settings.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$RandomizePort,
        [Switch]$GroupPolicy
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($RandomizePort -and -not $Enable) {
        throw "-RandomizePort can only be used with -Enable."
    }

    if ($GroupPolicy) {
        # Group Policy approach
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services"
        
        if ($Enable) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "fDenyTSConnections" -Value 0
            Set-GroupPolicyRegistry -Path $GPPath -Name "fSingleSessionPerUser" -Value 1
            
            if ($RandomizePort) {
                $RandomPort = Get-Random -Minimum 3390 -Maximum 65536
                Set-GroupPolicyRegistry -Path $GPPath -Name "PortNumber" -Value $RandomPort
                Write-Host "RDP enabled via Group Policy on port $RandomPort" -ForegroundColor Green
            } else {
                Write-Host "RDP enabled via Group Policy on default port 3389" -ForegroundColor Green
            }
        } elseif ($Disable) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "fDenyTSConnections" -Value 1
            Write-Host "RDP disabled via Group Policy" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } else {
        # Original direct registry approach
        if ($Enable) {
            Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
            Set-Service -Name "TermService" -StartupType Automatic
            
            if ($RandomizePort) {
                $RandomPort = Get-Random -Minimum 3390 -Maximum 65536
                Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp" -Name "PortNumber" -Value $RandomPort
                Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "PortNumber" -Value $RandomPort
                New-NetFirewallRule -DisplayName "Remote Desktop - Custom Port" -Direction Inbound -Protocol TCP -LocalPort $RandomPort -Action Allow -ErrorAction SilentlyContinue
                Write-Host "RDP enabled on port $RandomPort (restart required for port change to take effect)" -ForegroundColor Green
            } else {
                Write-Host "RDP enabled on default port 3389" -ForegroundColor Green
            }
        } elseif ($Disable) {
            Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 1
            Stop-Service -Name "TermService" -Force
            Set-Service -Name "TermService" -StartupType Disabled
            Remove-NetFirewallRule -DisplayName "Remote Desktop - Custom Port" -ErrorAction SilentlyContinue
            Write-Host "RDP disabled" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    }
}

# Modified Set-SMBv1 function with Group Policy support
function Set-SMBv1 {
    <#
    .SYNOPSIS
    Enables or disables SMBv1 protocol.

    .DESCRIPTION
    This function modifies SMB server configuration to enable or disable SMBv1.
    Use `-Enable` to allow SMBv1 or `-Disable` to block it.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.

    .PARAMETER Enable
    Enables SMBv1.

    .PARAMETER Disable
    Disables SMBv1.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry instead of direct SMB configuration.

    .EXAMPLE
    Set-SMBv1 -Enable
    Enables SMBv1.

    .EXAMPLE
    Set-SMBv1 -Disable
    Disables SMBv1.

    .EXAMPLE
    Set-SMBv1 -Disable -GroupPolicy
    Disables SMBv1 using Group Policy registry settings.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($GroupPolicy) {
        # Group Policy approach
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\LanmanServer\Parameters"
        
        if ($Enable) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "SMB1" -Value 1
            Write-Host "SMBv1 enabled via Group Policy" -ForegroundColor Green
        } elseif ($Disable) {
            Set-GroupPolicyRegistry -Path $GPPath -Name "SMB1" -Value 0
            Write-Host "SMBv1 disabled via Group Policy" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } else {
        # Original direct configuration approach
        if ($Enable) {
            Set-SmbServerConfiguration -EnableSMB1Protocol $true -Force
            Write-Host "SMBv1 enabled" -ForegroundColor Green
        } elseif ($Disable) {
            Set-SmbServerConfiguration -EnableSMB1Protocol $false -Force
            Write-Host "SMBv1 disabled" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    }
}

# Modified Set-AutoRun function with Group Policy support
function Set-AutoRun {
    <#
    .SYNOPSIS
    Enables or disables AutoRun/AutoPlay for removable media.

    .DESCRIPTION
    This function configures registry settings to control AutoRun and AutoPlay functionality.
    Use `-Enable` to allow AutoRun or `-Disable` to block it for enhanced security.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.

    .PARAMETER Enable
    Enables AutoRun/AutoPlay.

    .PARAMETER Disable
    Disables AutoRun/AutoPlay.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry instead of direct registry modification.

    .EXAMPLE
    Set-AutoRun -Enable
    Enables AutoRun/AutoPlay.

    .EXAMPLE
    Set-AutoRun -Disable
    Disables AutoRun/AutoPlay.

    .EXAMPLE
    Set-AutoRun -Disable -GroupPolicy
    Disables AutoRun/AutoPlay using Group Policy registry settings.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($GroupPolicy) {
        # Group Policy approach
        $GPPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Explorer"
        
        if ($Enable) {
            try {
                Remove-ItemProperty -Path $GPPath -Name "NoDriveTypeAutoRun" -ErrorAction SilentlyContinue
                Remove-ItemProperty -Path $GPPath -Name "NoAutorun" -ErrorAction SilentlyContinue
                Write-Host "AutoRun/AutoPlay enabled via Group Policy" -ForegroundColor Green
            } catch {
                Write-Host "Failed to enable AutoRun via Group Policy: $_" -ForegroundColor Red
            }
        } elseif ($Disable) {
            try {
                Set-GroupPolicyRegistry -Path $GPPath -Name "NoDriveTypeAutoRun" -Value 255
                Set-GroupPolicyRegistry -Path $GPPath -Name "NoAutorun" -Value 1
                Write-Host "AutoRun/AutoPlay disabled via Group Policy" -ForegroundColor Green
            } catch {
                Write-Host "Failed to disable AutoRun via Group Policy: $_" -ForegroundColor Red
            }
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } else {
        # Original direct registry approach
        if ($Enable) {
            try {
                Remove-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" -Name "NoDriveTypeAutoRun" -ErrorAction SilentlyContinue
                Remove-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" -Name "NoDriveTypeAutoRun" -ErrorAction SilentlyContinue
                Remove-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" -Name "NoAutorun" -ErrorAction SilentlyContinue
                Write-Host "AutoRun/AutoPlay enabled" -ForegroundColor Green
            } catch {
                Write-Host "Failed to enable AutoRun: $_" -ForegroundColor Red
            }
        } elseif ($Disable) {
            try {
                $RegistryPaths = @(
                    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer",
                    "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer"
                )
                
                foreach ($Path in $RegistryPaths) {
                    if (-not (Test-Path $Path)) {
                        New-Item -Path $Path -Force | Out-Null
                    }
                    Set-ItemProperty -Path $Path -Name "NoDriveTypeAutoRun" -Value 255
                    Set-ItemProperty -Path $Path -Name "NoAutorun" -Value 1
                }
                Write-Host "AutoRun/AutoPlay disabled" -ForegroundColor Green
            } catch {
                Write-Host "Failed to disable AutoRun: $_" -ForegroundColor Red
            }
        } else {
            throw "Specify either -Enable or -Disable."
        }
    }
}

# Modified Set-Macros function with Group Policy support
function Set-Macros {
    <#
    .SYNOPSIS
    Enables or disables macros in Microsoft Office applications.

    .DESCRIPTION
    This function configures registry settings to control macro execution in Office applications.
    Use `-Enable` to allow macros or `-Disable` to block all macros for enhanced security.
    Use `-GroupPolicy` to apply the setting via Group Policy registry.
    Supports Office 2016, 2019, 2021, and Office 365.

    .PARAMETER Enable
    Enables macros in Office applications.

    .PARAMETER Disable
    Disables all macros in Office applications.

    .PARAMETER GroupPolicy
    Applies the setting via Group Policy registry instead of direct registry modification.

    .EXAMPLE
    Set-Macros -Enable
    Enables macros in Office applications.

    .EXAMPLE
    Set-Macros -Disable
    Disables all macros in Office applications.

    .EXAMPLE
    Set-Macros -Disable -GroupPolicy
    Disables macros using Group Policy registry settings.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    $OfficeApps = @("Excel", "Word", "PowerPoint", "Access", "Outlook", "Publisher", "Visio")
    $OfficeVersions = @("16.0", "15.0", "14.0") # Office 2016/2019/2021/365, 2013, 2010

    if ($GroupPolicy) {
        # Group Policy approach
        $GPBasePath = "HKLM:\SOFTWARE\Policies\Microsoft\Office"
        
        if ($Enable) {
            Write-Host "Enabling macros in Office applications via Group Policy..."
            foreach ($Version in $OfficeVersions) {
                foreach ($App in $OfficeApps) {
                    $GPPath = "$GPBasePath\$Version\$App\Security"
                    try {
                        # Remove blocking policies to enable macros
                        Remove-ItemProperty -Path $GPPath -Name "VBAWarnings" -ErrorAction SilentlyContinue
                        Remove-ItemProperty -Path $GPPath -Name "BlockContentExecutionFromInternet" -ErrorAction SilentlyContinue
                        Write-Host "Macros enabled for $App $Version via Group Policy" -ForegroundColor Green
                    } catch {
                        Write-Host "Note: No existing macro policy found for $App $Version" -ForegroundColor Yellow
                    }
                }
            }
        } elseif ($Disable) {
            Write-Host "Disabling macros in Office applications via Group Policy..."
            foreach ($Version in $OfficeVersions) {
                foreach ($App in $OfficeApps) {
                    $GPPath = "$GPBasePath\$Version\$App\Security"
                    try {
                        Set-GroupPolicyRegistry -Path $GPPath -Name "VBAWarnings" -Value 4
                        Set-GroupPolicyRegistry -Path $GPPath -Name "BlockContentExecutionFromInternet" -Value 1
                        Write-Host "Macros disabled for $App $Version via Group Policy" -ForegroundColor Green
                    } catch {
                        Write-Host "Failed to disable macros for $App $Version via Group Policy" -ForegroundColor Yellow
                    }
                }
            }
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } else {
        # Original direct user registry approach
        if ($Enable) {
            Write-Host "Enabling macros in Office applications..."
            foreach ($Version in $OfficeVersions) {
                foreach ($App in $OfficeApps) {
                    $RegistryPath = "HKCU:\Software\Microsoft\Office\$Version\$App\Security"
                    
                    if (Test-Path $RegistryPath) {
                        try {
                            Set-ItemProperty -Path $RegistryPath -Name "VBAWarnings" -Value 1 -ErrorAction SilentlyContinue
                            Write-Host "Macros enabled for $App $Version" -ForegroundColor Green
                        } catch {
                            Write-Host "Failed to enable macros for $App $Version" -ForegroundColor Yellow
                        }
                    }
                }
            }
            Write-Host "Macro enabling complete." -ForegroundColor Green
        } elseif ($Disable) {
            Write-Host "Disabling macros in Office applications..."
            foreach ($Version in $OfficeVersions) {
                foreach ($App in $OfficeApps) {
                    $RegistryPath = "HKCU:\Software\Microsoft\Office\$Version\$App\Security"
                    
                    if (-not (Test-Path $RegistryPath)) {
                        try {
                            New-Item -Path $RegistryPath -Force | Out-Null
                        } catch {
                            continue
                        }
                    }
                    
                    try {
                        Set-ItemProperty -Path $RegistryPath -Name "VBAWarnings" -Value 4
                        Set-ItemProperty -Path $RegistryPath -Name "BlockContentExecutionFromInternet" -Value 1 -ErrorAction SilentlyContinue
                        Write-Host "Macros disabled for $App $Version" -ForegroundColor Green
                    } catch {
                        Write-Host "Failed to disable macros for $App $Version" -ForegroundColor Yellow
                    }
                }
            }
            Write-Host "Macro disabling complete." -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    }
}

# Modified Set-Ghost function with Group Policy support
function Set-Ghost {
    <#
    .SYNOPSIS
    Disables various protocols and services for hardening the server.

    .DESCRIPTION
    This function disables specific protocols and services for increased security. Supported features include RDP,
    ICMP, LLMNR, NetBIOS, LDAP, PowerShell Remoting, SMBv1, Remote Assistance, Network Discovery, and Macros.
    Use -GroupPolicy to apply settings via Group Policy registry instead of direct configuration.
    Written by Jim Tyler.

    .PARAMETER RDP
    Disables Remote Desktop Protocol (RDP).

    .PARAMETER ICMP
    Disables ICMP (ping).

    .PARAMETER LLMNR
    Disables Link-Local Multicast Name Resolution.

    .PARAMETER NetBIOS
    Disables NetBIOS over TCP/IP.

    .PARAMETER LDAP
    Disables LDAP service.

    .PARAMETER PSRemoting
    Disables PowerShell Remoting.

    .PARAMETER SMBv1
    Disables SMBv1 protocol.

    .PARAMETER RemoteAssistance
    Disables Remote Assistance.

    .PARAMETER NetworkDiscovery
    Disables Network Discovery.

    .PARAMETER Macros
    Disables macros in Microsoft Office applications.

    .PARAMETER AutoRun
    Disables AutoRun/AutoPlay for removable media.

    .PARAMETER USBStorage
    Disables USB storage devices.

    .PARAMETER AdminShares
    Disables administrative shares (C$, ADMIN$, etc.).

    .PARAMETER Telemetry
    Disables Windows telemetry and data collection.

    .PARAMETER GuestAccount
    Disables the Guest account.

    .PARAMETER WinRM
    Disables Windows Remote Management.

    .PARAMETER GroupPolicy
    Applies all settings via Group Policy registry instead of direct configuration.

    .EXAMPLE
    Set-Ghost -RDP -ICMP -LLMNR
    Disables RDP, ICMP, and LLMNR using direct configuration.

    .EXAMPLE
    Set-Ghost -SMBv1 -AutoRun -Macros -GroupPolicy
    Disables SMBv1, AutoRun, and Macros using Group Policy registry settings.

    .EXAMPLE
    Set-Ghost -RDP -SMBv1 -AutoRun -GroupPolicy
    Disables RDP, SMBv1, and AutoRun using Group Policy for domain-wide application.
    
    .EXAMPLE
    Set-Ghost -RDP -SMBv1 -USBStorage -AutoRun -Intune
    Creates Intune policies to disable RDP, SMBv1, USB storage, and AutoRun across managed devices.

    
    #>
    param(
        [Switch]$RDP,
        [Switch]$ICMP,
        [Switch]$LLMNR,
        [Switch]$NetBIOS,
        [Switch]$LDAP,
        [Switch]$PSRemoting,
        [Switch]$SMBv1,
        [Switch]$RemoteAssistance,
        [Switch]$NetworkDiscovery,
        [Switch]$Macros,
        [Switch]$AutoRun,
        [Switch]$USBStorage,
        [Switch]$AdminShares,
        [Switch]$Telemetry,
        [Switch]$GuestAccount,
        [Switch]$WinRM,
        [Switch]$GroupPolicy,
        [Switch]$Intune
    )
 if ($GroupPolicy -and $Intune) {
        throw "Cannot specify both -GroupPolicy and -Intune. Choose one deployment method."
    }

    if ($Intune) {
        Write-Host "Deploying Ghost security settings via Microsoft Intune..." -ForegroundColor Cyan
        
        # Build settings hashtable for Intune deployment
        $IntuneSettings = @{}
        if ($RDP) { $IntuneSettings.RDP = $true }
        if ($ICMP) { $IntuneSettings.ICMP = $true }
        if ($LLMNR) { $IntuneSettings.LLMNR = $true }
        if ($NetBIOS) { $IntuneSettings.NetBIOS = $true }
        if ($LDAP) { $IntuneSettings.LDAP = $true }
        if ($PSRemoting) { $IntuneSettings.PSRemoting = $true }
        if ($SMBv1) { $IntuneSettings.SMBv1 = $true }
        if ($RemoteAssistance) { $IntuneSettings.RemoteAssistance = $true }
        if ($NetworkDiscovery) { $IntuneSettings.NetworkDiscovery = $true }
        if ($Macros) { $IntuneSettings.Macros = $true }
        if ($AutoRun) { $IntuneSettings.AutoRun = $true }
        if ($USBStorage) { $IntuneSettings.USBStorage = $true }
        if ($AdminShares) { $IntuneSettings.AdminShares = $true }
        if ($Telemetry) { $IntuneSettings.Telemetry = $true }
        if ($GuestAccount) { $IntuneSettings.GuestAccount = $true }
        if ($WinRM) { $IntuneSettings.WinRM = $true }

        if ($IntuneSettings.Count -gt 0) {
            Set-IntuneGhost -Settings $IntuneSettings -Interactive
        } else {
            Write-Host "No settings specified for Intune deployment." -ForegroundColor Yellow
        }
        
        return
    }
    t
    if ($GroupPolicy) {
        Write-Host "Applying security hardening via Group Policy registry settings..." -ForegroundColor Cyan
        Write-Host "Note: Group Policy settings will apply domain-wide and require 'gpupdate /force' or reboot" -ForegroundColor Yellow
    } else {
        Write-Host "Status prior to disabling:" -ForegroundColor Cyan
        Get-Ghost
    }

    if ($RDP) {
        Write-Host "Disabling RDP..."
        if ($GroupPolicy) {
            Set-RDP -Disable -GroupPolicy
        } else {
            Set-RDP -Disable
        }
    }

    if ($ICMP) {
        Write-Host "Disabling ICMP..."
        if ($GroupPolicy) {
            Set-ICMP -Disable -GroupPolicy
        } else {
            Set-ICMP -Disable
        }
    }

    if ($SMBv1) {
        Write-Host "Disabling SMBv1..."
        if ($GroupPolicy) {
            Set-SMBv1 -Disable -GroupPolicy
        } else {
            Set-SMBv1 -Disable
        }
    }

    if ($AutoRun) {
        Write-Host "Disabling AutoRun/AutoPlay..."
        if ($GroupPolicy) {
            Set-AutoRun -Disable -GroupPolicy
        } else {
            Set-AutoRun -Disable
        }
    }

    if ($Macros) {
        Write-Host "Disabling Macros..."
        if ($GroupPolicy) {
            Set-Macros -Disable -GroupPolicy
        } else {
            Set-Macros -Disable
        }
    }

    # Functions that don't have Group Policy equivalents yet (use original implementation)
    if ($LLMNR) {
        Write-Host "Disabling LLMNR..."
        Set-LLMNR -Disable
    }

    if ($NetBIOS) {
        Write-Host "Disabling NetBIOS..."
        Set-NetBIOS -Disable
    }

    if ($LDAP) {
        Write-Host "Disabling LDAP..."
        Set-LDAP -Disable
    }

    if ($PSRemoting) {
        Write-Host "Disabling PowerShell Remoting..."
        Set-PSRemoting -Disable
    }

    if ($RemoteAssistance) {
        Write-Host "Disabling Remote Assistance..."
        Set-RemoteAssistance -Disable
    }

    if ($NetworkDiscovery) {
        Write-Host "Disabling Network Discovery..."
        Set-NetworkDiscovery -Disable
    }

    if ($USBStorage) {
        Write-Host "Disabling USB Storage..."
        Set-USBStorage -Disable
    }

    if ($AdminShares) {
        Write-Host "Disabling Administrative Shares..."
        Set-AdminShares -Disable
    }

    if ($Telemetry) {
        Write-Host "Disabling Windows Telemetry..."
        Set-Telemetry -Disable
    }

    if ($GuestAccount) {
        Write-Host "Disabling Guest Account..."
        Set-GuestAccount -Disable
    }

    if ($WinRM) {
        Write-Host "Disabling Windows Remote Management..."
        Set-WinRM -Disable
    }

    if ($GroupPolicy) {
        Write-Host "Group Policy hardening complete!" -ForegroundColor Green
        Write-Host "Run 'gpupdate /force' to apply changes immediately, or wait for next GP refresh" -ForegroundColor Cyan
    } else {
        Write-Host "Protocol and service disabling complete." -ForegroundColor Green
        Write-Host "Status after disabling:" -ForegroundColor Cyan
        Get-Ghost
    }
}

function Set-ICMP {
    <#
    .SYNOPSIS
    Enables or disables ICMP (ping) for the server.
   
    .DESCRIPTION
    This function manages ICMP by adding or removing firewall rules that block ICMP packets.
    Use `-Enable` to allow ICMP traffic or `-Disable` to block ICMP traffic.
   
    .PARAMETER Enable
    Allows ICMP traffic.

    .PARAMETER Disable
    Blocks ICMP traffic.

    .EXAMPLE
    Set-ICMP -Enable
    Enables ICMP traffic.

    .EXAMPLE
    Set-ICMP -Disable
    Disables ICMP traffic.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($Enable) {
        Remove-NetFirewallRule -DisplayName "Disable ICMPv4-In" -ErrorAction SilentlyContinue
        Remove-NetFirewallRule -DisplayName "Disable ICMPv6-In" -ErrorAction SilentlyContinue
        Write-Host "ICMP enabled"
    } elseif ($Disable) {
        New-NetFirewallRule -DisplayName "Disable ICMPv4-In" -Protocol ICMPv4 -IcmpType 8 -Action Block
        New-NetFirewallRule -DisplayName "Disable ICMPv6-In" -Protocol ICMPv6 -Action Block
        Write-Host "ICMP disabled"
    } else {
        throw "Specify either -Enable or -Disable."
    }
}

function Set-RDP {
    <#
    .SYNOPSIS
    Enables or disables Remote Desktop Protocol (RDP).

    .DESCRIPTION
    This function configures RDP settings by modifying registry values and controlling the TermService service.
    Use `-Enable` to allow RDP access or `-Disable` to block RDP access.

    .PARAMETER Enable
    Enables RDP access.

    .PARAMETER Disable
    Disables RDP access.

    .EXAMPLE
    Set-RDP -Enable
    Enables RDP access.

    .EXAMPLE
    Set-RDP -Disable
    Disables RDP access.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($Enable) {
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
        #Start-Service -Name "TermService"
        Set-Service -Name "TermService" -StartupType Automatic
        Write-Host "RDP enabled"
    } elseif ($Disable) {
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 1
        Stop-Service -Name "TermService" -Force
        Set-Service -Name "TermService" -StartupType Disabled
        Write-Host "RDP disabled"
    } else {
        throw "Specify either -Enable or -Disable."
    }
}

function Set-LLMNR {
    <#
    .SYNOPSIS
    Disables Link-Local Multicast Name Resolution (LLMNR).

    .DESCRIPTION
    This function configures the registry to disable LLMNR by setting the `EnableMulticast` value to `0`.
    If the required registry path does not exist, it creates the path before setting the value.

    .EXAMPLE
    Set-LLMNR -Disable
    Disables LLMNR on the system.
    #>
    param(
        [Switch]$Disable
    )

    if ($Disable) {
        Write-Host "Disabling LLMNR..."
        $RegistryPath = "HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient"
        if (-not (Test-Path $RegistryPath)) {
            Write-Host "Registry path '$RegistryPath' does not exist. Creating path..."
            New-Item -Path "HKLM:\Software\Policies\Microsoft\Windows NT" -Name "DNSClient" -Force | Out-Null
        }

        Set-ItemProperty -Path $RegistryPath -Name "EnableMulticast" -Value 0
        Write-Host "LLMNR has been disabled."
    } else {
        Write-Host "No action taken. Use -Disable to disable LLMNR."
    }
}


# Additional functions for Set-NetBIOS, Set-LDAP, Set-PSRemoting, Set-SMBv1,
# Set-Firewall, Set-RemoteAssistance, and Set-NetworkDiscovery follow the same
# structure as the above examples. Detailed comments and -Enable/-Disable
# parameters are included for consistency.



function Set-NetBIOS {
    <#
    .SYNOPSIS
    Disables NetBIOS over TCP/IP on all network adapters.

    .DESCRIPTION
    This function disables NetBIOS by configuring the CIM class `Win32_NetworkAdapterConfiguration`.
    It ensures that all adapters have NetBIOS set to `Disabled`.

    .EXAMPLE
    Set-NetBIOS -Disable
    Disables NetBIOS over TCP/IP on all network adapters.
    #>
    param(
        [Switch]$Disable
    )

    if ($Disable) {
        # Disable NetBIOS on all network interfaces
        try {
            # Retrieve all network adapters where IP is enabled
            $Adapters = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled }

            if ($Adapters) {
                Write-Host "Disabling NetBIOS on all network interfaces..." -ForegroundColor Yellow
                foreach ($Adapter in $Adapters) {
                    # Call SetTcpipNetbios method with positional argument 2 (Disable NetBIOS)
                    $Result = $Adapter | Invoke-CimMethod -MethodName SetTcpipNetbios -Arguments @{ TcpipNetbiosOptions = 2 }
                    
                    if ($Result.ReturnValue -eq 0) {
                        Write-Host "NetBIOS successfully disabled on adapter: $($Adapter.Description)" -ForegroundColor Green
                    } else {
                        Write-Host "Failed to disable NetBIOS on adapter: $($Adapter.Description)" -ForegroundColor Red
                    }
                }
            } else {
                Write-Host "No network interfaces found with IP enabled." -ForegroundColor Yellow
            }
        } catch {
            Write-Host "An error occurred while disabling NetBIOS: $_" -ForegroundColor Red
        }
}

}



function Set-LDAP {
    <#
    .SYNOPSIS
    Enables or disables the LDAP service on the server.

    .DESCRIPTION
    This function starts or stops the LDAP (NTDS) service and adjusts its startup type.
    Use `-Enable` to start the service or `-Disable` to stop it.

    .PARAMETER Enable
    Enables the LDAP service.

    .PARAMETER Disable
    Disables the LDAP service.

    .EXAMPLE
    Set-LDAP -Enable
    Enables LDAP.

    .EXAMPLE
    Set-LDAP -Disable
    Disables LDAP.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($Enable) {
        #Start-Service -Name "NTDS"
        Set-Service -Name "NTDS" -StartupType Automatic
        Write-Host "LDAP enabled"
    } elseif ($Disable) {
        Stop-Service -Name "NTDS" -Force
        Set-Service -Name "NTDS" -StartupType Disabled
        Write-Host "LDAP disabled"
    } else {
        throw "Specify either -Enable or -Disable."
    }
}


function Set-PSRemoting {
    <#
    .SYNOPSIS
    Disables PowerShell Remoting.

    .DESCRIPTION
    This function disables PowerShell Remoting by configuring the WSMan service. It also accounts for cases
    where the WSMan provider or configuration cannot be detected.

    .PARAMETER Disable
    Disables PowerShell Remoting.

    .EXAMPLE
    Set-PSRemoting -Disable
    Disables PowerShell Remoting.
    #>
    param(
        [Switch]$Disable
    )

    if ($Disable) {
        Write-Host "Attempting to disable PowerShell Remoting..."

        # Check if WSMan provider is available
        if (-not (Test-Path "WSMan:\localhost\Service")) {
            Write-Host "PowerShell Remoting status cannot be detected. WSMan provider not available." -ForegroundColor Yellow
            return
        }

        try {
            # Check current status of PowerShell Remoting
            $PSRemotingStatus = (Get-Item -Path "WSMan:\localhost\Service").Enabled -eq $true

            if ($PSRemotingStatus) {
                Write-Host "PowerShell Remoting is currently enabled. Disabling..."
                Disable-PSRemoting -Force
                Write-Host "PowerShell Remoting has been disabled." -ForegroundColor Green
            } else {
                Write-Host "PowerShell Remoting is already disabled." -ForegroundColor Green
            }
        } catch {
            Write-Host "An error occurred while attempting to disable PowerShell Remoting: $_" -ForegroundColor Red
        }
    } else {
        Write-Host "No action taken. Use -Disable to disable PowerShell Remoting."
    }
}





function Set-SMBv1 {
    <#
    .SYNOPSIS
    Enables or disables SMBv1 protocol.

    .DESCRIPTION
    This function modifies SMB server configuration to enable or disable SMBv1.
    Use `-Enable` to allow SMBv1 or `-Disable` to block it.

    .PARAMETER Enable
    Enables SMBv1.

    .PARAMETER Disable
    Disables SMBv1.

    .EXAMPLE
    Set-SMBv1 -Enable
    Enables SMBv1.

    .EXAMPLE
    Set-SMBv1 -Disable
    Disables SMBv1.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($Enable) {
        Set-SmbServerConfiguration -EnableSMB1Protocol $true -Force
        Write-Host "SMBv1 enabled"
    } elseif ($Disable) {
        Set-SmbServerConfiguration -EnableSMB1Protocol $false -Force
        Write-Host "SMBv1 disabled"
    } else {
        throw "Specify either -Enable or -Disable."
    }
}



function Set-Firewall {
    <#
    .SYNOPSIS
    Enables or disables Windows Firewall.

    .DESCRIPTION
    This function adjusts the state of the firewall for all profiles (Domain, Private, Public).
    Use `-Enable` to turn the firewall on or `-Disable` to turn it off.

    .PARAMETER Enable
    Enables the Windows Firewall.

    .PARAMETER Disable
    Disables the Windows Firewall.

    .EXAMPLE
    Set-Firewall -Enable
    Enables the firewall.

    .EXAMPLE
    Set-Firewall -Disable
    Disables the firewall.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($Enable) {
        Set-NetFirewallProfile -Profile Domain,Private,Public -Enabled True
        Write-Host "Firewall enabled"
    } elseif ($Disable) {
        Set-NetFirewallProfile -Profile Domain,Private,Public -Enabled False
        Write-Host "Firewall disabled"
    } else {
        throw "Specify either -Enable or -Disable."
    }
}



function Set-RemoteAssistance {
    <#
    .SYNOPSIS
    Enables or disables Remote Assistance.

    .DESCRIPTION
    This function modifies registry values to enable or disable Remote Assistance.
    Use `-Enable` to allow it or `-Disable` to block it.

    .PARAMETER Enable
    Enables Remote Assistance.

    .PARAMETER Disable
    Disables Remote Assistance.

    .EXAMPLE
    Set-RemoteAssistance -Enable
    Enables Remote Assistance.

    .EXAMPLE
    Set-RemoteAssistance -Disable
    Disables Remote Assistance.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($Enable) {
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Remote Assistance" -Name "fAllowToGetHelp" -Value 1
        Write-Host "Remote Assistance enabled"
    } elseif ($Disable) {
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Remote Assistance" -Name "fAllowToGetHelp" -Value 0
        Write-Host "Remote Assistance disabled"
    } else {
        throw "Specify either -Enable or -Disable."
    }
}


function Set-NetworkDiscovery {
    <#
    .SYNOPSIS
    Enables or disables Network Discovery.

    .DESCRIPTION
    This function controls services related to network discovery (FDResPub and SSDPDiscovery).
    Use `-Enable` to start these services or `-Disable` to stop them.

    .PARAMETER Enable
    Enables Network Discovery.

    .PARAMETER Disable
    Disables Network Discovery.

    .EXAMPLE
    Set-NetworkDiscovery -Enable
    Enables Network Discovery.

    .EXAMPLE
    Set-NetworkDiscovery -Disable
    Disables Network Discovery.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) {
        throw "Specify either -Enable or -Disable, not both."
    }

    if ($Enable) {
        Set-Service -Name "FDResPub" -StartupType Automatic
        Set-Service -Name "SSDPDiscovery" -StartupType Automatic
        #Start-Service -Name "FDResPub"
        #Start-Service -Name "SSDPDiscovery"
        Write-Host "Network Discovery enabled"
    } elseif ($Disable) {
        Stop-Service -Name "FDResPub"
        Stop-Service -Name "SSDPDiscovery"
        Set-Service -Name "FDResPub" -StartupType Disabled
        Set-Service -Name "SSDPDiscovery" -StartupType Disabled
        Write-Host "Network Discovery disabled"
    } else {
        throw "Specify either -Enable or -Disable."
    }
}









# Consolidated Set-Ghost and helper functions (to replace $SELECTION_PLACEHOLDER$)
function Set-Ghost {
    <#
    .SYNOPSIS
    Disables various protocols and services for hardening the server.

    .DESCRIPTION
    This function disables specific protocols and services for increased security.
    Supports RDP, ICMP, LLMNR, NetBIOS, LDAP, PowerShell Remoting, SMBv1,
    Remote Assistance, Network Discovery, AutoRun, USBStorage, AdminShares,
    Telemetry, GuestAccount, WinRM and allows Group Policy or Intune deployment.

    .PARAMETER RDP,ICMP,LLMNR,NetBIOS,LDAP,PSRemoting,SMBv1,RemoteAssistance,NetworkDiscovery
    .PARAMETER AutoRun,USBStorage,AdminShares,Telemetry,GuestAccount,WinRM
    .PARAMETER GroupPolicy
    Apply via Group Policy registry keys.
    .PARAMETER Intune
    Create Intune policies instead of local changes.
    #>
    param(
        [Switch]$RDP,
        [Switch]$ICMP,
        [Switch]$LLMNR,
        [Switch]$NetBIOS,
        [Switch]$LDAP,
        [Switch]$PSRemoting,
        [Switch]$SMBv1,
        [Switch]$RemoteAssistance,
        [Switch]$NetworkDiscovery,
        [Switch]$AutoRun,
        [Switch]$USBStorage,
        [Switch]$AdminShares,
        [Switch]$Telemetry,
        [Switch]$GuestAccount,
        [Switch]$WinRM,
        [Switch]$GroupPolicy,
        [Switch]$Intune
    )

    if ($GroupPolicy -and $Intune) {
        throw "Cannot specify both -GroupPolicy and -Intune. Choose one deployment method."
    }

    if ($Intune) {
        Write-Host "Deploying Ghost security settings via Microsoft Intune..." -ForegroundColor Cyan
        $IntuneSettings = @{}
        if ($RDP) { $IntuneSettings.RDP = $true }
        if ($ICMP) { $IntuneSettings.ICMP = $true }
        if ($LLMNR) { $IntuneSettings.LLMNR = $true }
        if ($NetBIOS) { $IntuneSettings.NetBIOS = $true }
        if ($LDAP) { $IntuneSettings.LDAP = $true }
        if ($PSRemoting) { $IntuneSettings.PSRemoting = $true }
        if ($SMBv1) { $IntuneSettings.SMBv1 = $true }
        if ($RemoteAssistance) { $IntuneSettings.RemoteAssistance = $true }
        if ($NetworkDiscovery) { $IntuneSettings.NetworkDiscovery = $true }
        if ($AutoRun) { $IntuneSettings.AutoRun = $true }
        if ($USBStorage) { $IntuneSettings.USBStorage = $true }
        if ($AdminShares) { $IntuneSettings.AdminShares = $true }
        if ($Telemetry) { $IntuneSettings.Telemetry = $true }
        if ($GuestAccount) { $IntuneSettings.GuestAccount = $true }
        if ($WinRM) { $IntuneSettings.WinRM = $true }

        if ($IntuneSettings.Count -gt 0) {
            Set-IntuneGhost -Settings $IntuneSettings -Interactive
        } else {
            Write-Host "No settings specified for Intune deployment." -ForegroundColor Yellow
        }
        return
    }

    Write-Host "Status prior to disabling:" -ForegroundColor Cyan
    Get-Ghost

    if ($RDP) {
        Write-Host "Disabling RDP..."
        if ($GroupPolicy) { Set-RDP -Disable -GroupPolicy } else { Set-RDP -Disable }
    }

    if ($ICMP) {
        Write-Host "Disabling ICMP..."
        if ($GroupPolicy) { Set-ICMP -Disable -GroupPolicy } else { Set-ICMP -Disable }
    }

    if ($LLMNR) {
        Write-Host "Disabling LLMNR..."
        Set-LLMNR -Disable
    }

    if ($NetBIOS) {
        Write-Host "Disabling NetBIOS..."
        Set-NetBIOS -Disable
    }

    if ($LDAP) {
        Write-Host "Disabling LDAP..."
        Set-LDAP -Disable
    }

    if ($PSRemoting) {
        Write-Host "Disabling PowerShell Remoting..."
        Set-PSRemoting -Disable
    }

    if ($SMBv1) {
        Write-Host "Disabling SMBv1..."
        if ($GroupPolicy) { Set-SMBv1 -Disable -GroupPolicy } else { Set-SMBv1 -Disable }
    }

    if ($RemoteAssistance) {
        Write-Host "Disabling Remote Assistance..."
        if ($GroupPolicy) { Set-RemoteAssistance -Disable } else { Set-RemoteAssistance -Disable }
    }

    if ($NetworkDiscovery) {
        Write-Host "Disabling Network Discovery..."
        Set-NetworkDiscovery -Disable
    }

    if ($AutoRun) {
        Write-Host "Disabling AutoRun/AutoPlay..."
        if ($GroupPolicy) { Set-AutoRun -Disable -GroupPolicy } else { Set-AutoRun -Disable }
    }

    if ($USBStorage) {
        Write-Host "Disabling USB Storage..."
        Set-USBStorage -Disable -GroupPolicy:$GroupPolicy
    }

    if ($AdminShares) {
        Write-Host "Disabling Administrative Shares..."
        Set-AdminShares -Disable -GroupPolicy:$GroupPolicy
    }

    if ($Telemetry) {
        Write-Host "Disabling Telemetry..."
        Set-Telemetry -Disable -GroupPolicy:$GroupPolicy
    }

    if ($GuestAccount) {
        Write-Host "Disabling Guest Account..."
        Set-GuestAccount -Disable -GroupPolicy:$GroupPolicy
    }

    if ($WinRM) {
        Write-Host "Disabling WinRM..."
        Set-WinRM -Disable
    }

    Write-Host "Protocol and service disabling complete." -ForegroundColor Green
    Write-Host "Status after disabling:" -ForegroundColor Cyan
    Get-Ghost
}

function Set-LLMNR {
    <#
    .SYNOPSIS
    Disable LLMNR via registry.
    #>
    param(
        [Switch]$Disable
    )
    if ($Disable) {
        try {
            $RegistryPath = "HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient"
            if (-not (Test-Path $RegistryPath)) {
                New-Item -Path "HKLM:\Software\Policies\Microsoft\Windows NT" -Name "DNSClient" -Force | Out-Null
            }
            Set-ItemProperty -Path $RegistryPath -Name "EnableMulticast" -Value 0 -Type DWord -ErrorAction Stop
            Write-Host "LLMNR disabled." -ForegroundColor Green
        } catch {
            Write-Host "Failed to disable LLMNR: $_" -ForegroundColor Red
        }
    } else {
        Write-Host "No action taken. Use -Disable to disable LLMNR." -ForegroundColor Yellow
    }
}

function Set-NetBIOS {
    <#
    .SYNOPSIS
    Disable NetBIOS over TCP/IP on all adapters.
    #>
    param(
        [Switch]$Disable
    )
    if ($Disable) {
        try {
            $Adapters = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled }
            if (-not $Adapters) {
                Write-Host "No IP-enabled adapters found." -ForegroundColor Yellow
                return
            }
            foreach ($Adapter in $Adapters) {
                $result = $Adapter | Invoke-CimMethod -MethodName SetTcpipNetbios -Arguments @{ TcpipNetbiosOptions = 2 } -ErrorAction SilentlyContinue
                if ($result -and $result.ReturnValue -eq 0) {
                    Write-Host "NetBIOS disabled on adapter: $($Adapter.Description)" -ForegroundColor Green
                } else {
                    Write-Host "NetBIOS: unable to change on adapter: $($Adapter.Description) (result: $($result.ReturnValue))" -ForegroundColor Yellow
                }
            }
        } catch {
            Write-Host "Error disabling NetBIOS: $_" -ForegroundColor Red
        }
    } else {
        Write-Host "No action taken. Use -Disable to disable NetBIOS." -ForegroundColor Yellow
    }
}

function Set-LDAP {
    <#
    .SYNOPSIS
    Start/stop NTDS (LDAP) service.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }
    try {
        if ($Enable) {
            Set-Service -Name "NTDS" -StartupType Automatic -ErrorAction SilentlyContinue
            Start-Service -Name "NTDS" -ErrorAction SilentlyContinue
            Write-Host "LDAP (NTDS) enabled." -ForegroundColor Green
        } elseif ($Disable) {
            Stop-Service -Name "NTDS" -Force -ErrorAction SilentlyContinue
            Set-Service -Name "NTDS" -StartupType Disabled -ErrorAction SilentlyContinue
            Write-Host "LDAP (NTDS) disabled." -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure LDAP/NTDS: $_" -ForegroundColor Red
    }
}

function Set-PSRemoting {
    <#
    .SYNOPSIS
    Disable PowerShell Remoting (WSMan).
    #>
    param(
        [Switch]$Disable
    )
    if ($Disable) {
        try {
            if (-not (Test-Path "WSMan:\localhost\Service")) {
                Write-Host "WSMan provider not available; attempting to stop WinRM service." -ForegroundColor Yellow
                if (Get-Service -Name "WinRM" -ErrorAction SilentlyContinue) {
                    Stop-Service -Name "WinRM" -Force -ErrorAction SilentlyContinue
                    Set-Service -Name "WinRM" -StartupType Disabled -ErrorAction SilentlyContinue
                }
                Write-Host "PowerShell Remoting disabled (best-effort)." -ForegroundColor Green
                return
            }
            $status = (Get-Item -Path "WSMan:\localhost\Service").Enabled
            if ($status) {
                Disable-PSRemoting -Force -ErrorAction SilentlyContinue
                Write-Host "PowerShell Remoting disabled." -ForegroundColor Green
            } else {
                Write-Host "PowerShell Remoting already disabled." -ForegroundColor Green
            }
        } catch {
            Write-Host "Error disabling PowerShell Remoting: $_" -ForegroundColor Red
        }
    } else {
        Write-Host "No action taken. Use -Disable to disable PowerShell Remoting." -ForegroundColor Yellow
    }
}

function Set-Firewall {
    <#
    .SYNOPSIS
    Enable/disable Windows Firewall for all profiles.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }
    try {
        if ($Enable) {
            Set-NetFirewallProfile -Profile Domain,Private,Public -Enabled True -ErrorAction SilentlyContinue
            Write-Host "Firewall enabled for all profiles." -ForegroundColor Green
        } elseif ($Disable) {
            Set-NetFirewallProfile -Profile Domain,Private,Public -Enabled False -ErrorAction SilentlyContinue
            Write-Host "Firewall disabled for all profiles." -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure firewall: $_" -ForegroundColor Red
    }
}

function Set-RemoteAssistance {
    <#
    .SYNOPSIS
    Enable/disable Remote Assistance.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }
    try {
        if ($Enable) {
            Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Remote Assistance" -Name "fAllowToGetHelp" -Value 1 -ErrorAction SilentlyContinue
            Write-Host "Remote Assistance enabled." -ForegroundColor Green
        } elseif ($Disable) {
            Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Remote Assistance" -Name "fAllowToGetHelp" -Value 0 -ErrorAction SilentlyContinue
            Write-Host "Remote Assistance disabled." -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure Remote Assistance: $_" -ForegroundColor Red
    }
}

function Set-NetworkDiscovery {
    <#
    .SYNOPSIS
    Enable/disable Network Discovery by controlling FDResPub and SSDPDiscovery services.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )
    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }
    try {
        if ($Enable) {
            foreach ($svc in @("FDResPub","SSDPDiscovery")) {
                if (Get-Service -Name $svc -ErrorAction SilentlyContinue) {
                    Set-Service -Name $svc -StartupType Automatic -ErrorAction SilentlyContinue
                    Start-Service -Name $svc -ErrorAction SilentlyContinue
                }
            }
            Write-Host "Network Discovery services started/enabled." -ForegroundColor Green
        } elseif ($Disable) {
            foreach ($svc in @("FDResPub","SSDPDiscovery")) {
                if (Get-Service -Name $svc -ErrorAction SilentlyContinue) {
                    Stop-Service -Name $svc -Force -ErrorAction SilentlyContinue
                    Set-Service -Name $svc -StartupType Disabled -ErrorAction SilentlyContinue
                }
            }
            Write-Host "Network Discovery services stopped/disabled." -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure Network Discovery: $_" -ForegroundColor Red
    }
}





function Write-Status {
    param(
        [string]$ServiceName,
        [AllowNull()]$IsEnabled
    )

    # Handle non-Boolean values
    if ($IsEnabled -eq $true) {
        Write-Host "${ServiceName}: Enabled" -ForegroundColor Red
    } elseif ($IsEnabled -eq $false) {
        Write-Host "${ServiceName}: Disabled" -ForegroundColor Green
    } elseif ([string]::IsNullOrEmpty($IsEnabled)) {
        Write-Host "${ServiceName}: Status Unknown (Empty Value)" -ForegroundColor Yellow
    } else {
        Write-Host "${ServiceName}: Status Unknown (Invalid Value)" -ForegroundColor Yellow
    }
}




function Get-Ghost {
    <#
    .SYNOPSIS
    Retrieves the status of various protocols and services and provides recommendations for hardening.

    .DESCRIPTION
    This cmdlet checks the status of specific protocols and services, such as RDP, ICMP, LLMNR, NetBIOS, LDAP,
    PowerShell Remoting, SMBv1, Remote Assistance, Network Discovery, AutoRun, USB storage, Office macros,
    telemetry and Guest account. Enabled services are collected and a suggested Set-Ghost command is displayed.
    The function is resilient when cmdlets or registry keys are missing.
    #>

    # Helper to report and collect enabled params (paramName must match Set-Ghost parameter name)
    $EnabledProtocols = @()
    function ReportStatus {
        param(
            [string]$DisplayName,
            [string]$ParamName,
            [AllowNull()]$Status
        )
        Write-Status -ServiceName $DisplayName -IsEnabled $Status
        if ($Status -eq $true -and $ParamName) {
            $EnabledProtocols += $ParamName
        }
    }

    # RDP
    try {
        if (Test-Path "HKLM:\System\CurrentControlSet\Control\Terminal Server") {
            $val = (Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -ErrorAction SilentlyContinue).fDenyTSConnections
            $RDPStatus = if ($null -ne $val) { $val -eq 0 } else { $null }
        } else {
            $RDPStatus = $null
        }
    } catch { $RDPStatus = $null }
    ReportStatus -DisplayName "RDP" -ParamName "RDP" -Status $RDPStatus

    # ICMP (depends on NetFirewall cmdlets)
    if (Get-Command -Name Get-NetFirewallRule -ErrorAction SilentlyContinue) {
        try {
            $ICMPRule = Get-NetFirewallRule -DisplayName "Disable ICMPv4-In" -ErrorAction SilentlyContinue
            $ICMPStatus = if ($ICMPRule) { $false } else { $true }
        } catch { $ICMPStatus = $null }
    } else {
        $ICMPStatus = $null
    }
    ReportStatus -DisplayName "ICMP" -ParamName "ICMP" -Status $ICMPStatus

    # LLMNR
    try {
        if (Test-Path "HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient") {
            $val = (Get-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient" -Name "EnableMulticast" -ErrorAction SilentlyContinue).EnableMulticast
            $LLMNRStatus = if ($null -ne $val) { $val -ne 0 } else { $null }
        } else {
            $LLMNRStatus = $null
        }
    } catch { $LLMNRStatus = $null }
    ReportStatus -DisplayName "LLMNR" -ParamName "LLMNR" -Status $LLMNRStatus

    # NetBIOS
    try {
        if (Get-Command -Name Get-CimInstance -ErrorAction SilentlyContinue) {
            $Adapters = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled } -ErrorAction SilentlyContinue
            if ($Adapters) {
                $anyNotDisabled = $Adapters | Where-Object { $_.TcpipNetbiosOptions -ne 2 }
                if ($anyNotDisabled -and $anyNotDisabled.Count -gt 0) { $NetBIOSStatus = $true } else { $NetBIOSStatus = $false }
            } else {
                $NetBIOSStatus = $null
            }
        } else {
            $NetBIOSStatus = $null
        }
    } catch { $NetBIOSStatus = $null }
    ReportStatus -DisplayName "NetBIOS" -ParamName "NetBIOS" -Status $NetBIOSStatus

    # LDAP (NTDS service presence)
    try {
        $svc = Get-Service -Name "NTDS" -ErrorAction SilentlyContinue
        $LDAPStatus = if ($svc) { $svc.Status -eq 'Running' } else { $null }
    } catch { $LDAPStatus = $null }
    ReportStatus -DisplayName "LDAP" -ParamName "LDAP" -Status $LDAPStatus

    # PowerShell Remoting (WinRM / WSMan)
    try {
        if (Test-Path "WSMan:\localhost\Service") {
            $enabled = (Get-Item -Path "WSMan:\localhost\Service").Enabled -eq $true
            $PSRemotingStatus = $enabled
        } else {
            $WinRMService = Get-Service -Name "WinRM" -ErrorAction SilentlyContinue
            $PSRemotingStatus = if ($WinRMService) { $WinRMService.Status -eq 'Running' } else { $null }
        }
    } catch { $PSRemotingStatus = $null }
    ReportStatus -DisplayName "PowerShell Remoting" -ParamName "PSRemoting" -Status $PSRemotingStatus

    # SMBv1
    if (Get-Command -Name Get-SmbServerConfiguration -ErrorAction SilentlyContinue) {
        try {
            $SMBv1Status = (Get-SmbServerConfiguration -ErrorAction Stop).EnableSMB1Protocol
        } catch { $SMBv1Status = $null }
    } else {
        $SMBv1Status = $null
    }
    ReportStatus -DisplayName "SMBv1" -ParamName "SMBv1" -Status $SMBv1Status

    # Remote Assistance
    try {
        if (Test-Path "HKLM:\System\CurrentControlSet\Control\Remote Assistance") {
            $val = (Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Remote Assistance" -Name "fAllowToGetHelp" -ErrorAction SilentlyContinue).fAllowToGetHelp
            $RemoteAssistanceStatus = if ($null -ne $val) { $val -eq 1 } else { $null }
        } else {
            $RemoteAssistanceStatus = $null
        }
    } catch { $RemoteAssistanceStatus = $null }
    ReportStatus -DisplayName "Remote Assistance" -ParamName "RemoteAssistance" -Status $RemoteAssistanceStatus

    # Network Discovery (FDResPub and SSDPDiscovery)
    try {
        $fd = Get-Service -Name "FDResPub" -ErrorAction SilentlyContinue
        $ssdp = Get-Service -Name "SSDPDiscovery" -ErrorAction SilentlyContinue
        if ($fd -or $ssdp) {
            $fdRunning = if ($fd) { $fd.Status -eq 'Running' } else { $false }
            $ssdpRunning = if ($ssdp) { $ssdp.Status -eq 'Running' } else { $false }
            $NetworkDiscoveryStatus = if ($fdRunning -or $ssdpRunning) { $true } else { $false }
        } else {
            $NetworkDiscoveryStatus = $null
        }
    } catch { $NetworkDiscoveryStatus = $null }
    ReportStatus -DisplayName "Network Discovery" -ParamName "NetworkDiscovery" -Status $NetworkDiscoveryStatus

    # AutoRun / AutoPlay
    try {
        $policyPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Explorer"
        $policyExists = Test-Path $policyPath
        $localPaths = @(
            "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer",
            "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer"
        )
        $autoRunDisabled = $false
        if ($policyExists) {
            $pd = Get-ItemProperty -Path $policyPath -ErrorAction SilentlyContinue
            if ($pd -and (($pd.NoDriveTypeAutoRun -eq 255) -or ($pd.NoAutorun -eq 1))) { $autoRunDisabled = $true }
        }
        foreach ($p in $localPaths) {
            if (Test-Path $p) {
                $lv = Get-ItemProperty -Path $p -ErrorAction SilentlyContinue
                if ($lv -and (($lv.NoDriveTypeAutoRun -eq 255) -or ($lv.NoAutorun -eq 1))) { $autoRunDisabled = $true }
            }
        }
        if ($policyExists -or (Test-Path $localPaths[0]) -or (Test-Path $localPaths[1])) {
            $AutoRunStatus = if ($autoRunDisabled) { $false } else { $true }
        } else {
            $AutoRunStatus = $null
        }
    } catch { $AutoRunStatus = $null }
    ReportStatus -DisplayName "AutoRun/AutoPlay" -ParamName "AutoRun" -Status $AutoRunStatus

    # USB Storage (USBSTOR service Start)
    try {
        $svcPath = "HKLM:\SYSTEM\CurrentControlSet\Services\USBSTOR"
        if (Test-Path $svcPath) {
            $start = (Get-ItemProperty -Path $svcPath -Name "Start" -ErrorAction SilentlyContinue).Start
            if ($null -ne $start) {
                $USBStorageStatus = if ($start -eq 4) { $false } else { $true }
            } else {
                $USBStorageStatus = $null
            }
        } else {
            $USBStorageStatus = $null
        }
    } catch { $USBStorageStatus = $null }
    ReportStatus -DisplayName "USB Storage" -ParamName "USBStorage" -Status $USBStorageStatus

    # Office Macros (check policy and user registry heuristics)
    try {
        $foundSetting = $false
        $macroEnabled = $false
        $officeVersions = @("16.0","15.0","14.0")
        $officeApps = @("Excel","Word","PowerPoint","Access","Outlook","Publisher","Visio")
        $policyBase = "HKLM:\SOFTWARE\Policies\Microsoft\Office"
        foreach ($ver in $officeVersions) {
            foreach ($app in $officeApps) {
                $policyPath = "$policyBase\$ver\$app\Security"
                $userPath = "HKCU:\Software\Microsoft\Office\$ver\$app\Security"
                if (Test-Path $policyPath) {
                    $p = Get-ItemProperty -Path $policyPath -ErrorAction SilentlyContinue
                    if ($p -and $p.VBAWarnings) {
                        $foundSetting = $true
                        if ($p.VBAWarnings -lt 4) { $macroEnabled = $true }
                    }
                }
                if (Test-Path $userPath) {
                    $u = Get-ItemProperty -Path $userPath -ErrorAction SilentlyContinue
                    if ($u -and $u.VBAWarnings) {
                        $foundSetting = $true
                        if ($u.VBAWarnings -lt 4) { $macroEnabled = $true }
                    }
                }
            }
        }
        if ($foundSetting) {
            $MacrosStatus = if ($macroEnabled) { $true } else { $false }
        } else {
            $MacrosStatus = $null
        }
    } catch { $MacrosStatus = $null }
    ReportStatus -DisplayName "Office Macros" -ParamName "Macros" -Status $MacrosStatus

    # Telemetry
    try {
        $dcPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection"
        if (Test-Path $dcPath) {
            $val = (Get-ItemProperty -Path $dcPath -Name "AllowTelemetry" -ErrorAction SilentlyContinue).AllowTelemetry
            if ($null -ne $val) { $TelemetryStatus = if ($val -eq 0) { $false } else { $true } } else { $TelemetryStatus = $null }
        } else {
            $TelemetryStatus = $null
        }
    } catch { $TelemetryStatus = $null }
    ReportStatus -DisplayName "Telemetry" -ParamName "Telemetry" -Status $TelemetryStatus

    # Guest account
    try {
        if (Get-Command -Name Get-LocalUser -ErrorAction SilentlyContinue) {
            $guest = Get-LocalUser -Name "Guest" -ErrorAction SilentlyContinue
            if ($guest) { $GuestAccountStatus = $guest.Enabled } else { $GuestAccountStatus = $null }
        } else {
            $out = (& net user Guest) 2>$null
            if ($out) {
                $line = $out | Where-Object { $_ -match "Account active" -or $_ -match "Account active" }
                if ($line) {
                    $GuestAccountStatus = $line -match "Yes"
                } else {
                    $GuestAccountStatus = $null
                }
            } else {
                $GuestAccountStatus = $null
            }
        }
    } catch { $GuestAccountStatus = $null }
    ReportStatus -DisplayName "Guest Account" -ParamName "GuestAccount" -Status $GuestAccountStatus

    # Administrative Shares (AutoShareServer / AutoShareWks)
    try {
        $serverPath = "HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters"
        if (Test-Path $serverPath) {
            $p = Get-ItemProperty -Path $serverPath -ErrorAction SilentlyContinue
            if ($p) {
                $as = $p.AutoShareServer
                $aw = $p.AutoShareWks
                # If either value is explicitly 0 -> admin shares disabled, otherwise treat as enabled
                if (($null -ne $as -and $as -eq 0) -and ($null -ne $aw -and $aw -eq 0)) {
                    $AdminSharesStatus = $false
                } elseif ($null -ne $as -or $null -ne $aw) {
                    $AdminSharesStatus = $true
                } else {
                    $AdminSharesStatus = $null
                }
            } else {
                $AdminSharesStatus = $null
            }
        } else {
            $AdminSharesStatus = $null
        }
    } catch { $AdminSharesStatus = $null }
    ReportStatus -DisplayName "Administrative Shares" -ParamName "AdminShares" -Status $AdminSharesStatus

    # Execution Policy - informational only (not part of Set-Ghost params)
    try {
        $ExecutionPolicy = Get-ExecutionPolicy -Scope LocalMachine -ErrorAction SilentlyContinue
        if ($ExecutionPolicy) {
            if ($ExecutionPolicy -in @("Unrestricted","Bypass")) {
                Write-Host "Execution Policy: $ExecutionPolicy (Consider setting to a more restrictive policy, e.g. AllSigned or Restricted)" -ForegroundColor Red
            } elseif ($ExecutionPolicy -eq "RemoteSigned") {
                Write-Host "Execution Policy: RemoteSigned (Consider changing to 'Restricted' for maximum safety)" -ForegroundColor Yellow
            } elseif ($ExecutionPolicy -eq "Restricted") {
                Write-Host "Execution Policy: Restricted (Most restrictive  good)" -ForegroundColor Green
            } else {
                Write-Host "Execution Policy: $ExecutionPolicy (Adequately restrictive)" -ForegroundColor Green
            }
        } else {
            Write-Host "Execution Policy: Unknown" -ForegroundColor Yellow
        }
    } catch {
        Write-Host "Execution Policy: Status Unknown (error encountered)" -ForegroundColor Yellow
    }
    # Assessments for recently added functions

    # UPnP (upnphost, SSDPSRV)
    try {
        $upnpServices = @("upnphost","SSDPSRV")
        $found = $false; $running = $false
        foreach ($s in $upnpServices) {
            $svc = Get-Service -Name $s -ErrorAction SilentlyContinue
            if ($svc) {
                $found = $true
                if ($svc.Status -eq 'Running') { $running = $true }
            }
        }
        if (-not $found) { $UPnPStatus = $null } else { $UPnPStatus = $running }
    } catch { $UPnPStatus = $null }
    ReportStatus -DisplayName "UPnP (Device Host / SSDP)" -ParamName "UPnP" -Status $UPnPStatus

    # Windows Time Service (NTP server/provider)
    try {
        $w32path = "HKLM:\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer"
        $w32svc = Get-Service -Name "W32Time" -ErrorAction SilentlyContinue
        if (Test-Path $w32path) {
            $val = (Get-ItemProperty -Path $w32path -Name "Enabled" -ErrorAction SilentlyContinue).Enabled
            if ($null -ne $val) {
                # Treat Enabled=1 as allowing NTP responses (exposed), Enabled=0 as hardened
                $WindowsTimeServiceStatus = ($val -ne 0)
            } else {
                $WindowsTimeServiceStatus = $null
            }
        } elseif ($w32svc) {
            $WindowsTimeServiceStatus = ($w32svc.Status -eq 'Running')
        } else {
            $WindowsTimeServiceStatus = $null
        }
    } catch { $WindowsTimeServiceStatus = $null }
    ReportStatus -DisplayName "Windows Time Service (NTP server)" -ParamName "WindowsTimeService" -Status $WindowsTimeServiceStatus

    # Service Banners (LegalNoticeCaption / LegalNoticeText)
    try {
        $sysPolicyPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        $gpPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\System"
        $caption = $null; $text = $null
        if (Test-Path $gpPath) {
            $p = Get-ItemProperty -Path $gpPath -ErrorAction SilentlyContinue
            $caption = $p.LegalNoticeCaption
            $text = $p.LegalNoticeText
        }
        if (($null -eq $caption -and $null -eq $text) -and (Test-Path $sysPolicyPath)) {
            $u = Get-ItemProperty -Path $sysPolicyPath -ErrorAction SilentlyContinue
            $caption = $u.LegalNoticeCaption
            $text = $u.LegalNoticeText
        }
        if ($null -ne $caption -or $null -ne $text) {
            # Presence of values indicates custom banners (information disclosure)
            $ServiceBannersStatus = $true
        } else {
            $ServiceBannersStatus = $false
        }
    } catch { $ServiceBannersStatus = $null }
    ReportStatus -DisplayName "Service Banners (Legal Notice)" -ParamName "ServiceBanners" -Status $ServiceBannersStatus

    # IPv6 Privacy / Reconnaissance vectors
    try {
        $tcp6Path = "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters"
        if (Test-Path $tcp6Path) {
            $dc = (Get-ItemProperty -Path $tcp6Path -Name "DisabledComponents" -ErrorAction SilentlyContinue).DisabledComponents
            if ($null -ne $dc) {
                # 255 typically means IPv6 components disabled -> treat as hardened (privacy/recon disabled) => Status = $false
                $IPv6PrivacyStatus = if ($dc -eq 255) { $false } else { $true }
            } else {
                $IPv6PrivacyStatus = $null
            }
        } else {
            $IPv6PrivacyStatus = $null
        }
    } catch { $IPv6PrivacyStatus = $null }
    ReportStatus -DisplayName "IPv6 / Privacy Extensions" -ParamName "IPv6Privacy" -Status $IPv6PrivacyStatus

    # Anonymous access / LSA anonymous restrictions
    try {
        $lsaPath = "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa"
        if (Test-Path $lsaPath) {
            $l = Get-ItemProperty -Path $lsaPath -ErrorAction SilentlyContinue
            $ras = $l.RestrictAnonymousSAM
            $ra  = $l.RestrictAnonymous
            $eia = $l.EveryoneIncludesAnonymous
            if ($null -ne $ras -or $null -ne $ra -or $null -ne $eia) {
                # If settings explicitly restrict anonymous access (RAS=1, RA=2, EIA=0) treat AnonymousAccess as disabled (false)
                if (($ras -eq 1) -and ($ra -eq 2) -and ($eia -eq 0)) {
                    $AnonymousAccessStatus = $false
                } else {
                    $AnonymousAccessStatus = $true
                }
            } else {
                $AnonymousAccessStatus = $null
            }
        } else {
            $AnonymousAccessStatus = $null
        }
    } catch { $AnonymousAccessStatus = $null }
    ReportStatus -DisplayName "Anonymous Access (LSA)" -ParamName "AnonymousAccess" -Status $AnonymousAccessStatus
    # Suggest Actions Based On Detected Settings/Features/Services
    if ($EnabledProtocols.Count -gt 0) {
        Write-Host "`nThe following settings, features or services appear to be enabled and are candidates for hardening:" -ForegroundColor Yellow
        $EnabledProtocols | ForEach-Object { Write-Host " - $_" -ForegroundColor Red }

        # Build suggestion command using collected param names
        $Suggestion = "Set-Ghost"
        foreach ($p in $EnabledProtocols) { $Suggestion += " -$p" }

        Write-Host "`nSuggestion: A single Set-Ghost command with switches for the items above is shown. Review and adjust (Group Policy or Intune deployment may be preferred) before running:" -ForegroundColor Yellow
        Write-Host $Suggestion -ForegroundColor Cyan
    } else {
        Write-Host "`nNo detected settings/features/services were found that Set-Ghost would change automatically. Manual review or additional checks may still be required." -ForegroundColor Green
    }
}






function Set-USBStorage {
    <#
    .SYNOPSIS
    Enables or disables USB mass storage (USBSTOR).

    .DESCRIPTION
    Disables by setting the USBSTOR service Start value to 4 (Disabled).
    Enables by setting it to 3 (Manual). Optionally notes Group Policy intent.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )

    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }

    $svcPath = "HKLM:\SYSTEM\CurrentControlSet\Services\USBSTOR"
    try {
        if ($Disable) {
            if (-not (Test-Path $svcPath)) { New-Item -Path $svcPath -Force | Out-Null }
            Set-ItemProperty -Path $svcPath -Name "Start" -Value 4 -Type DWord -ErrorAction Stop
            Write-Host "USB mass storage disabled (USBSTOR Start=4)" -ForegroundColor Green
            if ($GroupPolicy) { Write-Host "Applied via registry path intended for Group Policy deployment." -ForegroundColor Yellow }
        } elseif ($Enable) {
            if (-not (Test-Path $svcPath)) { New-Item -Path $svcPath -Force | Out-Null }
            Set-ItemProperty -Path $svcPath -Name "Start" -Value 3 -Type DWord -ErrorAction Stop
            Write-Host "USB mass storage enabled (USBSTOR Start=3)" -ForegroundColor Green
            if ($GroupPolicy) { Write-Host "Applied via registry path intended for Group Policy deployment." -ForegroundColor Yellow }
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure USB storage: $_" -ForegroundColor Red
    }
}

function Set-WinRM {
    <#
    .SYNOPSIS
    Enables or disables Windows Remote Management (WinRM).

    .DESCRIPTION
    Controls the WinRM service startup type and running state.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable
    )

    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }

    try {
        if ($Enable) {
            Set-Service -Name "WinRM" -StartupType Automatic -ErrorAction Stop
            Start-Service -Name "WinRM" -ErrorAction SilentlyContinue
            Write-Host "WinRM enabled and started" -ForegroundColor Green
        } elseif ($Disable) {
            Stop-Service -Name "WinRM" -Force -ErrorAction SilentlyContinue
            Set-Service -Name "WinRM" -StartupType Disabled -ErrorAction Stop
            Write-Host "WinRM disabled and stopped" -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure WinRM: $_" -ForegroundColor Red
    }
}

function Set-AdminShares {
    <#
    .SYNOPSIS
    Enables or disables administrative shares (AutoShareServer / AutoShareWks).

    .DESCRIPTION
    Sets AutoShareServer and AutoShareWks under LanmanServer parameters or via Group Policy registry.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )

    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }

    $serverPath = "HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters"
    try {
        if ($Disable) {
            if ($GroupPolicy) {
                Set-GroupPolicyRegistry -Path $serverPath -Name "AutoShareServer" -Value 0
                Set-GroupPolicyRegistry -Path $serverPath -Name "AutoShareWks" -Value 0
            } else {
                if (-not (Test-Path $serverPath)) { New-Item -Path $serverPath -Force | Out-Null }
                Set-ItemProperty -Path $serverPath -Name "AutoShareServer" -Value 0 -Type DWord -ErrorAction Stop
                Set-ItemProperty -Path $serverPath -Name "AutoShareWks" -Value 0 -Type DWord -ErrorAction Stop
            }
            Write-Host "Administrative shares disabled (AutoShareServer/AutoShareWks = 0). Restart required for full effect." -ForegroundColor Green
        } elseif ($Enable) {
            if ($GroupPolicy) {
                Set-GroupPolicyRegistry -Path $serverPath -Name "AutoShareServer" -Value 1
                Set-GroupPolicyRegistry -Path $serverPath -Name "AutoShareWks" -Value 1
            } else {
                if (-not (Test-Path $serverPath)) { New-Item -Path $serverPath -Force | Out-Null }
                Set-ItemProperty -Path $serverPath -Name "AutoShareServer" -Value 1 -Type DWord -ErrorAction Stop
                Set-ItemProperty -Path $serverPath -Name "AutoShareWks" -Value 1 -Type DWord -ErrorAction Stop
            }
            Write-Host "Administrative shares enabled (AutoShareServer/AutoShareWks = 1)." -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure administrative shares: $_" -ForegroundColor Red
    }
}

function Set-Telemetry {
    <#
    .SYNOPSIS
    Enables or disables Windows telemetry/data collection.

    .DESCRIPTION
    Sets DataCollection\AllowTelemetry policy and stops telemetry services when disabling.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )

    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }

    $dcPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection"
    try {
        if ($Disable) {
            if ($GroupPolicy) {
                Set-GroupPolicyRegistry -Path $dcPath -Name "AllowTelemetry" -Value 0
            } else {
                if (-not (Test-Path $dcPath)) { New-Item -Path $dcPath -Force | Out-Null }
                Set-ItemProperty -Path $dcPath -Name "AllowTelemetry" -Value 0 -Type DWord -ErrorAction Stop
            }

            # Stop telemetry related services where applicable
            foreach ($svc in @("DiagTrack","dmwappushservice")) {
                if (Get-Service -Name $svc -ErrorAction SilentlyContinue) {
                    try { Stop-Service -Name $svc -Force -ErrorAction SilentlyContinue; Set-Service -Name $svc -StartupType Disabled -ErrorAction SilentlyContinue } catch {}
                }
            }

            Write-Host "Telemetry reduced/disabled via policy (AllowTelemetry=0) and telemetry services stopped where possible." -ForegroundColor Green
        } elseif ($Enable) {
            if ($GroupPolicy) {
                Set-GroupPolicyRegistry -Path $dcPath -Name "AllowTelemetry" -Value 3
            } else {
                if (-not (Test-Path $dcPath)) { New-Item -Path $dcPath -Force | Out-Null }
                Set-ItemProperty -Path $dcPath -Name "AllowTelemetry" -Value 3 -Type DWord -ErrorAction Stop
            }

            foreach ($svc in @("DiagTrack","dmwappushservice")) {
                if (Get-Service -Name $svc -ErrorAction SilentlyContinue) {
                    try { Set-Service -Name $svc -StartupType Manual -ErrorAction SilentlyContinue; Start-Service -Name $svc -ErrorAction SilentlyContinue } catch {}
                }
            }

            Write-Host "Telemetry set to default/allowed level (AllowTelemetry=3) and services started where possible." -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure telemetry: $_" -ForegroundColor Red
    }
}

function Set-GuestAccount {
    <#
    .SYNOPSIS
    Enables or disables the built-in Guest account.

    .DESCRIPTION
    Uses the LocalAccounts module when available or falls back to net user.
    #>
    param(
        [Switch]$Enable,
        [Switch]$Disable,
        [Switch]$GroupPolicy
    )

    if ($Enable -and $Disable) { throw "Specify either -Enable or -Disable, not both." }

    try {
        if ($Disable) {
            if (Get-Command -Name "Set-LocalUser" -ErrorAction SilentlyContinue) {
                $guest = Get-LocalUser -Name "Guest" -ErrorAction SilentlyContinue
                if ($guest) { Set-LocalUser -Name "Guest" -Enabled $false -ErrorAction Stop }
            } else {
                & net user Guest /active:no | Out-Null
            }
            Write-Host "Guest account disabled." -ForegroundColor Green
            if ($GroupPolicy) { Write-Host "Consider enforcing this via Group Policy for domain scenarios." -ForegroundColor Yellow }
        } elseif ($Enable) {
            if (Get-Command -Name "Set-LocalUser" -ErrorAction SilentlyContinue) {
                $guest = Get-LocalUser -Name "Guest" -ErrorAction SilentlyContinue
                if ($guest) { Set-LocalUser -Name "Guest" -Enabled $true -ErrorAction Stop }
            } else {
                & net user Guest /active:yes | Out-Null
            }
            Write-Host "Guest account enabled." -ForegroundColor Green
        } else {
            throw "Specify either -Enable or -Disable."
        }
    } catch {
        Write-Host "Failed to configure Guest account: $_" -ForegroundColor Red
    }
}

Export-ModuleMember -Function `
    Set-UPnP, Set-WindowsTimeService, Set-ServiceBanners, Set-IPv6Privacy, Set-AnonymousAccess, `
    Connect-IntuneGhost, Set-IntuneGhost, `
    New-IntuneDeviceRestrictionPolicy, New-IntuneEndpointSecurityPolicy, New-IntuneOfficePolicy, New-IntunePowerShellScript, `
    Set-GroupPolicyRegistry, Write-Status, `
    Set-ICMP, Set-RDP, Set-SMBv1, Set-AutoRun, Set-Macros, Set-LLMNR, Set-NetBIOS, Set-LDAP, Set-PSRemoting, `
    Set-Firewall, Set-RemoteAssistance, Set-NetworkDiscovery, `
    Set-USBStorage, Set-WinRM, Set-AdminShares, Set-Telemetry, Set-GuestAccount, `
    Get-Ghost, Set-Ghost, `
    Set-GhostTask, Remove-GhostTask, Get-GhostTask
